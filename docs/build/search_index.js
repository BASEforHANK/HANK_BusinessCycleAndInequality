var documenterSearchIndex = {"docs":
[{"location":"linearization.html#Linear-perturbation-around-steady-state","page":"Linearization","title":"Linear perturbation around steady state","text":"","category":"section"},{"location":"linearization.html","page":"Linearization","title":"Linearization","text":"note: Note\nThe main functions of this section are in the folder LinearizationFunctions.","category":"page"},{"location":"linearization.html","page":"Linearization","title":"Linearization","text":"The model is linearized with respect to aggregate variables. For this, we write the equilibrium conditions in the form of F(XX)=0, where X and X are (expected) deviations from steady state in two successive periods. Applying the total differential yields A*X = - B*X, where A,B are the first derivatives of F with respect to X,X. In the standard setting, we use the generalized Schur decomposition [Klein] to transform this equation into a linearized observation equation d = gx*k and a linearized state transition equation k = hx*k, where k is a vector of the state variables and d is a vector of the control variables (X = beginbmatrix k  d endbmatrix).","category":"page"},{"location":"linearization.html","page":"Linearization","title":"Linearization","text":"In our code, F is implemented as Fsys(), while differentiating and solving for gx and hx is done in SGU(), and linearize_full_model() returns the results as a struct LinearResults:","category":"page"},{"location":"linearization.html","page":"Linearization","title":"Linearization","text":"linearize_full_model","category":"page"},{"location":"linearization.html#HANKEstim.linearize_full_model","page":"Linearization","title":"HANKEstim.linearize_full_model","text":"linearize_full_model()\n\nLinearize the full solution (i.e. with idiosyncratic states and controls) around the steady state, using SGU().\n\nReturns\n\nstruct LinearResults, containing\n\nA::Array{Float64,2},B::Array{Float64,2}: first derivatives of Fsys() with respect to arguments X [B]   and XPrime [A]\nState2Control::Array{Float64,2}: observation equation\nLOMstate::Array{Float64,2}: state transition equation\n\n\n\n\n\n","category":"function"},{"location":"linearization.html#Overview-of-SGU()","page":"Linearization","title":"Overview of SGU()","text":"","category":"section"},{"location":"linearization.html","page":"Linearization","title":"Linearization","text":"SGU","category":"page"},{"location":"linearization.html#HANKEstim.SGU","page":"Linearization","title":"HANKEstim.SGU","text":"SGU(XSS,A,B,m_par,n_par,indexes,Copula,compressionIndexes,distrSS;estim)\n\nCalculate the linearized solution to the non-linear difference equations defined by function Fsys(), using Schmitt-Grohé & Uribe (JEDC 2004) style linearization (apply the implicit function theorem to obtain linear observation and state transition equations).\n\nThe Jacobian is calculated using the package ForwardDiff\n\nArguments\n\nXSS: steady state around which the system is linearized\nA,B: matrices to be filled with first derivatives (see Returns)\nm_par::ModelParameters, n_par::NumericalParameters: n_par.sol_algo determines   the solution algorithm\nCopula::Function,distrSS::Array{Float64,3}: Copula maps marginals to   linearized approximation of joint distribution around distrSS\nindexes::IndexStruct,compressionIndexes: access states and controls by name   (DCT coefficients of compressed V_m and V_k in case of   compressionIndexes)\n\nReturns\n\ngx,hx: observation equations [gx] and state transition equations [hx]\nalarm_sgu,nk: alarm_sgu=true when solving algorithm fails, nk number of   predetermined variables\nA,B: first derivatives of Fsys() with respect to arguments X [B] and   XPrime [A]\n\n\n\n\n\n","category":"function"},{"location":"linearization.html","page":"Linearization","title":"Linearization","text":"The function executes the following steps:","category":"page"},{"location":"linearization.html","page":"Linearization","title":"Linearization","text":"generate devices to retrieve distribution and marginal value functions from   compressed states/controls (Γ and DC,IDC)\ncalculate the first derivative of Fsys() with respect to X and XPrime.   We use automatic differentiation (implemented in Julia by the package ForwardDiff).   Partial derivatives are calculated using the ForwardDiff.jacobian() function.   We exploit that some partial derivatives have known values (contemporaneous marginal value   functions and the future marginal distributions) and set them directly instead of calculating them [BL].\ncompute linear observation and state transition equations using the SolveDiffEq() function","category":"page"},{"location":"linearization.html#Overview-of-SolveDiffEq()'","page":"Linearization","title":"Overview of `SolveDiffEq()'","text":"","category":"section"},{"location":"linearization.html","page":"Linearization","title":"Linearization","text":"SolveDiffEq","category":"page"},{"location":"linearization.html#HANKEstim.SolveDiffEq","page":"Linearization","title":"HANKEstim.SolveDiffEq","text":"SolveDiffEq(A, B, n_par; estim)\n\nCalculate the solution to the linearized difference equations defined B xt = A x{t+1}.\n\nArguments\n\nA,B: matrices with first derivatives \nn_par::NumericalParameters: n_par.sol_algo determines   the solution algorithm, options are: \nlitx:  Linear time iteration (improved implementation following Reiter fast if initial guess is good)\nschur: Klein's algorithm (fastest if no good initial guess is available)\n\nReturns\n\ngx,hx: observation equations [gx] and state transition equations [hx]\nalarm_sgu,nk: alarm_sgu=true when solving algorithm fails, nk number of   predetermined variables\n\n\n\n\n\n","category":"function"},{"location":"linearization.html","page":"Linearization","title":"Linearization","text":"compute linear observation and state transition equations. The solution algorithm is set   in n_par.sol_algo, with the options :schur (mentioned above) and :litx [lit]. The results are matrices that map contemporaneous states to controls [gx],   or contemporaneous states to future states [hx]","category":"page"},{"location":"linearization.html#Overview-of-Fsys()","page":"Linearization","title":"Overview of Fsys()","text":"","category":"section"},{"location":"linearization.html","page":"Linearization","title":"Linearization","text":"Fsys","category":"page"},{"location":"linearization.html#HANKEstim.Fsys","page":"Linearization","title":"HANKEstim.Fsys","text":"Fsys(X,XPrime,Xss,m_par,n_par,indexes,Γ,compressionIndexes,DC,IDC)\n\nEquilibrium error function: returns deviations from equilibrium around steady state.\n\nSplit computation into Aggregate Part, handled by Fsys_agg(), and Heterogeneous Agent Part.\n\nArguments\n\nX,XPrime: deviations from steady state in periods t [X] and t+1 [XPrime]\nXss: states and controls in steady state\nΓ,DC,IDC: transformation matrices to retrieve marginal distributions [Γ] and   marginal value functions [DC,IDC] from deviations\nindexes,compressionIndexes: access Xss by variable names   (DCT coefficients of compressed V_m and V_k in case of compressionIndexes)\n\nExample\n\njulia> # Solve for steady state, construct Γ,DC,IDC as in SGU()\njulia> Fsys(zeros(ntotal),zeros(ntotal),XSS,m_par,n_par,indexes,Γ,compressionIndexes,DC,IDC)\n*ntotal*-element Array{Float64,1}:\n 0.0\n 0.0\n ...\n 0.0\n\n\n\n\n\n","category":"function"},{"location":"linearization.html","page":"Linearization","title":"Linearization","text":"The function Fsys() proceeds in the following way:","category":"page"},{"location":"linearization.html","page":"Linearization","title":"Linearization","text":"set up vector F, that contains the errors to all equilibrium conditions. There are as many conditions  as deviations from steady state (length of X,XPrime), and conditions are indexed with  respective model variable in IndexStruct indexes\ngenerate locally all aggregate variables (for both periods) using @generate_equations\nconstruct the distributions and the marginal value functions from the steady state values  and the (compressed) deviations\nwrite all equilibrium condition-errors with respect to aggregate variables to F, using  Fsys_agg()\ncompute optimal policies with EGM_policyupdate(), given  future marginal value functions, prices, and individual incomes. Infer present marginal  value functions from them (envelope theorem) and set the difference to assumed present  marginal value functions (in terms of their compressed deviation from steady state)  as equilibrium condition-errors (backward iteration of the value function)\ncompute future distribution from previous distribution and optimal asset policies. Set  difference to assumed future marginal distributions as equilibrium condition-errors  (forward iteration of the distribution)\ncompute distribution summary statistics with distrSummaries() and write  equilibrium conditions with their respective (control) variables\nreturn F","category":"page"},{"location":"linearization.html#Called-functions-/-macros","page":"Linearization","title":"Called functions / macros","text":"","category":"section"},{"location":"linearization.html","page":"Linearization","title":"Linearization","text":"@generate_equations\nFsys_agg","category":"page"},{"location":"linearization.html#HANKEstim.@generate_equations","page":"Linearization","title":"HANKEstim.@generate_equations","text":"@generate_equations()\n\nWrite out the expansions around steady state for all variables in aggr_names, i.e. generate code that reads aggregate states/controls from steady state deviations.\n\nEquations take the form of (with variable r as example):\n\nr       = exp.(Xss[indexes.rSS] .+ X[indexes.r])\nrPrime  = exp.(Xss[indexes.rSS] .+ XPrime[indexes.r])\n\nRequires\n\n(module) global aggr_names\n\n\n\n\n\n","category":"macro"},{"location":"linearization.html#HANKEstim.Fsys_agg","page":"Linearization","title":"HANKEstim.Fsys_agg","text":"Fsys_agg(X,XPrime,Xss,distrSS,m_par,n_par,indexes)\n\nReturn deviations from aggregate equilibrium conditions.\n\nindexes can be both IndexStruct or IndexStructAggr; in the latter case (which is how function is called by SGU_estim()), variable-vectors X,XPrime, and Xss only contain the aggregate variables of the model.\n\n\n\n\n\n","category":"function"},{"location":"linearization.html","page":"Linearization","title":"Linearization","text":"[Klein]: See the paper Using the generalized Schur form to solve a multivariate linear rational expectations model by Paul Klein (JEDC 2000)","category":"page"},{"location":"linearization.html","page":"Linearization","title":"Linearization","text":"[BL]: Contemporaneous marginal value functions are irrelevant for optimal decisions, so its effect on other model variables is 0. Due to a rich enough set of prices, the future distribution directly only affects the Fokker-Planck equation. For details, see the paper Solving heterogeneous agent models in discrete time with many idiosyncratic states by perturbation methods","category":"page"},{"location":"linearization.html","page":"Linearization","title":"Linearization","text":"[lit]: Invoking the Implicit Function Theorem, there exist functions g and h such that Fleft(beginpmatrix k  g(k) endpmatrixbeginpmatrix h(k)  g(h(k)) endpmatrixright)=0. Totally differentiating by k yields B beginpmatrixmathbbI Dg endpmatrix+A beginpmatrixmathbbI Dg endpmatrix Dh = 0. The :lit-algorithm solves this equation for Dg and Dh iteratively.","category":"page"},{"location":"steadystate.html#Computation-of-the-steady-state-and-dimensionality-reduction","page":"Steady state","title":"Computation of the steady state and dimensionality reduction","text":"","category":"section"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"note: Note\nMost of the code of this section is in the folder 4_HetAgentsFcns.","category":"page"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"The model features uninsured income shocks y (by assumption, all workers supply the same efficiency units of labor [BBL], so idiosyncratic productivity shocks translate to income shocks) and two assets, bonds m and illiquid capital k. Entrepreneurs (last income-state) receive no labor income, but firm profits, while workers additionally receive labor union profits.                                                                                                ","category":"page"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"The steady state equilibrium contains marginal value functions V_m and V_k on a three-dimensional grid (m times k times y) and the ergodic joint distribution over these idiosyncratic states. We do dimensionality reduction [BL] by applying the Discrete Cosine Transformation to the marginal value functions and approximating the joint distribution with a copula and state-dependent marginals.","category":"page"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"The main functions are find_steadystate() and prepare_linearization():","category":"page"},{"location":"steadystate.html#Overview-of-find_steadystate","page":"Steady state","title":"Overview of find_steadystate","text":"","category":"section"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"find_steadystate","category":"page"},{"location":"steadystate.html#HANKEstim.find_steadystate","page":"Steady state","title":"HANKEstim.find_steadystate","text":"find_steadystate(m_par)\n\nFind the stationary equilibrium capital stock.\n\nReturns\n\nKSS: steady-state capital stock\nVmSS, VkSS: marginal value functions\ndistrSS::Array{Float64,3}: steady-state distribution of idiosyncratic states, computed by Ksupply()\nn_par::NumericalParameters,m_par::ModelParameters\n\n\n\n\n\n","category":"function"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"The function takes the parameter struct ModelParameters as input m_par (see Parameters).","category":"page"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"To find the stationary equilibrium, we proceed in roughly the following steps:","category":"page"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"instantiate the parameter struct NumericalParameters as n_par (see Parameters). Within the struct, we set the number of income states [ny] and use the Tauchen() method to obtain a grid and a transition matrix of income, given the autocorrelation of the income process [m_par.ρ_h]. Then, include entrepreneurial state.\nfind equilibrium capital stock (by finding a root of Kdiff()), where  the supply of capital by households is calculated in Ksupply(),  which uses the Endogenous Grid Method (see EGM_policyupdate)  to iteratively obtain optimal policies and marginal value functions","category":"page"},{"location":"steadystate.html#Overview-of-prepare_linearization","page":"Steady state","title":"Overview of prepare_linearization","text":"","category":"section"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"prepare_linearization","category":"page"},{"location":"steadystate.html#HANKEstim.prepare_linearization","page":"Steady state","title":"HANKEstim.prepare_linearization","text":"prepare_linearization(KSS, VmSS, VkSS, distrSS, n_par, m_par)\n\nCompute a number of equilibrium objects needed for linearization.\n\nArguments\n\nKSS: steady-state capital stock\nVmSS, VkSS: marginal value functions\ndistrSS::Array{Float64,3}: steady-state distribution of idiosyncratic states, computed by Ksupply()\nn_par::NumericalParameters,m_par::ModelParameters\n\nReturns\n\nXSS::Array{Float64,1}, XSSaggr::Array{Float64,1}: steady state vectors produced by @writeXSS()\nindexes, indexes_aggr: structs for accessing XSS,XSSaggr by variable names, produced by @make_fn(),       @make_fnaggr()\ncompressionIndexes::Array{Array{Int,1},1}: indexes for compressed marginal value functions (V_m and V_k)\nCopula(x,y,z): function that maps marginals x,y,z to approximated joint distribution, produced by       mylinearinterpolate3()\nn_par::NumericalParameters,m_par::ModelParameters\nCDF_SS, CDF_m, CDF_k, CDF_y: cumulative distribution functions (joint and marginals)\ndistrSS::Array{Float64,3}: steady state distribution of idiosyncratic states, computed by Ksupply()\n\n\n\n\n\n","category":"function"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"We first calculate other equilibrium quantities and produce distributional summary statistics (distrSummaries()). Next, we reduce the dimensionality:","category":"page"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"compute coefficients of the Chebyshev polynomials that serve as basis functions  for V_m and V_k, using the Discrete Cosine Transformation (Julia-package  FFTW), and retain those that explain the most of its variance, up to   100*(1-n_par.reduc) percent. Save their indices in compressionIndexes\ncompute the Copula as a function that maps three marginal  distributions to a linear interpolation of the joint distribution on its  marginals (see mylinearinterpolate3())","category":"page"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"Lastly, we collect the steady state values of all model variables in the  vector XSS (see @writeXSS). The state variables consist of the marginal distributions over m, k and y and the aggregate state variables (collected in state_names). The control variables consist of the steady state marginal value functions (over the full grid) and the aggregate control variables (collected in control_names; these vectors are defined in the main script HANKEstim.jl).","category":"page"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"While the steady state marginal value functions have full dimensionality, in the vectors that collect deviations from steady state (in Fsys(), those are X and XPrime) only the coefficients of the most important Chebyshev polynomials are saved. Additionally, the deviations of the marginal distributions are saved with one entry short of the grid size, since the marginals are restricted to sum up to 1. We manage this by creating the struct indexes (using @make_fn), that has two fields for each variable: steady state value and deviation.","category":"page"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"We also construct the vector XSSaggr and the struct indexes_aggr, which are similar to the above but only store (and manage) aggregate variables. This is useful for differentiating only with respect to aggregate variables in the estimation part (see SGU_estim()).","category":"page"},{"location":"steadystate.html#Parameters","page":"Steady state","title":"Parameters","text":"","category":"section"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"The model parameters for the steady state have to be calibrated. We set them in the struct ModelParameters. It also contains all other parameters that are estimated, including the stochastic process-parameters for the aggregate shocks.","category":"page"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"ModelParameters","category":"page"},{"location":"steadystate.html#HANKEstim.ModelParameters","page":"Steady state","title":"HANKEstim.ModelParameters","text":"ModelParameters()\n\nCollect all model parameters with calibrated values / priors for estimation in a struct.\n\nUses packages Parameters, FieldMetadata, Flatten. Boolean value denotes whether parameter is estimated.\n\nExample\n\njulia> m_par = ModelParameters();\njulia> # Obtain vector of prior distributions of parameters that are estimated.\njulia> priors = collect(metaflatten(m_par, prior))\n\n\n\n\n\n","category":"type"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"The numerical parameters contain the grid (and the meshes) on which the stationary equilibrium is solved, discretization results of find_steadystate()  like the transition matrix of income and the joint distribution, and other parameters that determine the numerical approximation or solution technique, like reduc or sol_algo.","category":"page"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"NumericalParameters","category":"page"},{"location":"steadystate.html#HANKEstim.NumericalParameters","page":"Steady state","title":"HANKEstim.NumericalParameters","text":"NumericalParameters()\n\nCollect parameters for the numerical solution of the model in a struct.\n\nUse package Parameters to provide initial values.\n\nExample\n\njulia> n_par = NumericalParameters(mmin = -6.6, mmax = 1000)\n\n\n\n\n\n","category":"type"},{"location":"steadystate.html#Find-stationary-equilibrium:-functions","page":"Steady state","title":"Find stationary equilibrium: functions","text":"","category":"section"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"Tauchen\nKdiff\nKsupply\nEGM_policyupdate\ndistrSummaries","category":"page"},{"location":"steadystate.html#HANKEstim.Tauchen","page":"Steady state","title":"HANKEstim.Tauchen","text":"Tauchen(rho,N,sigma,mue)\n\nGenerate a discrete approximation to an AR(1) process, following Tauchen (1987).\n\nUses importance sampling: each bin has probability 1/N to realize\n\nArguments\n\nrho: autocorrelation coefficient\nN: number of gridpoints\nsigma: long-run variance\nmue: mean of the AR(1) process\n\nReturns\n\ngrid_vec: state vector grid\nP: transition matrix\nbounds: bin bounds\n\n\n\n\n\n","category":"function"},{"location":"steadystate.html#HANKEstim.Kdiff","page":"Steady state","title":"HANKEstim.Kdiff","text":"Kdiff(K_guess,n_par,m_par)\n\nCalculate the difference between the capital stock that is assumed and the capital stock that prevails under that guessed capital stock's implied prices when households face idiosyncratic income risk (Aiyagari model).\n\nRequires global functions employment(K,A,m_par), interest(K,A,N,m_par), wage(K,A,N,m_par), output(K,TFP,N,m_par), and Ksupply().\n\nArguments\n\nK_guess::Float64: capital stock guess\nn_par::NumericalParameters, m_par::ModelParameters\n\n\n\n\n\n","category":"function"},{"location":"steadystate.html#HANKEstim.Ksupply","page":"Steady state","title":"HANKEstim.Ksupply","text":"Ksupply(RB_guess,R_guess,w_guess,profit_guess,n_par,m_par)\n\nCalculate the aggregate savings when households face idiosyncratic income risk.\n\nIdiosyncratic state is tuple (mky), where m: liquid assets, k: illiquid assets, y: labor income\n\nArguments\n\nR_guess: real interest rate illiquid assets\nRB_guess: nominal rate on liquid assets\nw_guess: wages\nprofit_guess: profits\nn_par::NumericalParameters\nm_par::ModelParameters\n\nReturns\n\nK,B: aggregate saving in illiquid (K) and liquid (B) assets\nTransitionMat,TransitionMat_a,TransitionMat_n: sparse transition matrices   (average, with [a] or without [n] adjustment of illiquid asset)\ndistr: ergodic steady state of TransitionMat\nc_a_star,m_a_star,k_a_star,c_n_star,m_n_star: optimal policies for   consumption [c], liquid [m] and illiquid [k] asset, with [a] or   without [n] adjustment of illiquid asset\nV_m,V_k: marginal value functions\n\n\n\n\n\n","category":"function"},{"location":"steadystate.html#HANKEstim.EGM_policyupdate","page":"Steady state","title":"HANKEstim.EGM_policyupdate","text":"EGM_policyupdate(EVm,EVk,Qminus,πminus,RBminus,Tshock,inc,n_par,m_par,warnme)\n\nFind optimal policies, given marginal continuation values EVm, EVk, today's prices [Qminus, πminus,RBminus], and income [inc], using the Endogenous Grid Method.\n\nOptimal policies are defined on the fixed grid, but optimal asset choices (m and k) are off-grid values.\n\nReturns\n\nc_a_star,m_a_star,k_a_star,c_n_star,m_n_star: optimal (on-grid) policies for   consumption [c], liquid [m] and illiquid [k] asset, with [a] or   without [n] adjustment of illiquid asset\n\n\n\n\n\n","category":"function"},{"location":"steadystate.html#HANKEstim.distrSummaries","page":"Steady state","title":"HANKEstim.distrSummaries","text":"distrSummaries(distr,c_a_star,c_n_star,n_par,inc,incgross,m_par)\n\nCompute distributional summary statistics, e.g. Gini indexes, top-10% income and wealth shares, and 10%, 50%, and 90%-consumption quantiles.\n\nArguments\n\ndistr: joint distribution over bonds, capital and income (m times k times y)\nc_a_star,c_n_star: optimal consumption policies with [a] or without [n]   capital adjustment\nn_par::NumericalParameters, m_par::ModelParameters\ninc: vector of (on grid-)incomes, consisting of labor income (scaled by fracgamma-tau^P1+gamma, plus labor union-profits),   rental income, liquid asset income, capital liquidation income,   labor income (scaled by frac1-tau^P1+gamma, without labor union-profits),   and labor income (without scaling or labor union-profits)\nincgross: vector of (on grid-) pre-tax incomes, consisting of   labor income (without scaling, plus labor union-profits), rental income,   liquid asset income, capital liquidation income,   labor income (without scaling or labor union-profits)\n\n\n\n\n\n","category":"function"},{"location":"steadystate.html#Dimensionality-reduction:-functions","page":"Steady state","title":"Dimensionality reduction: functions","text":"","category":"section"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"mylinearinterpolate3","category":"page"},{"location":"steadystate.html#HANKEstim.mylinearinterpolate3","page":"Steady state","title":"HANKEstim.mylinearinterpolate3","text":"mylinearinterpolate3(xgrd1,xgrd2,xgrd3,ygrd,xeval1,xeval2,xeval3)\n\nTrilineary project ygrd on (xgrd1,xgrd2,xgrd3) and use it to interpolate value at (xeval1,xeval2,xeval3).\n\nExample\n\njulia> xgrd = [1.0,6.0];\njulia> f((x,y,z)) = x+y+z;\njulia> ygrd = f.(collect(Iterators.product(xgrid,xgrid,xgrid));\njulia> xeval = [3.0,5.0];\njulia> mylinearinterpolate3(xgrd,xgrd,xgrd,ygrd,xeval,xeval,xeval)\n2x2x2 Array{Float64,3}:\n[:,:,1] =\n 9.0 11.0\n11.0 13.0\n[:,:,2] =\n11.0 13.0\n13.0 15.0\n\n\n\n\n\n","category":"function"},{"location":"steadystate.html#Collect-variables:-macros","page":"Steady state","title":"Collect variables: macros","text":"","category":"section"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"@writeXSS\n@make_fn\n@make_fnaggr\n@make_struct\n@make_struct_aggr","category":"page"},{"location":"steadystate.html#HANKEstim.@writeXSS","page":"Steady state","title":"HANKEstim.@writeXSS","text":"@writeXSS()\n\nWrite all single steady state variables into vectors XSS / XSSaggr.\n\nRequires\n\n(module) globals state_names, control_names, aggr_names\n\n\n\n\n\n","category":"macro"},{"location":"steadystate.html#HANKEstim.@make_fn","page":"Steady state","title":"HANKEstim.@make_fn","text":"@make_fn(fn_name)\n\nCreate function fn_name that returns an instance of struct IndexStruct (created by @make_struct), mapping states and controls to indexes inferred from numerical parameters and compression indexes.\n\nRequires\n\n(module) global state_names, control_names\n\n\n\n\n\n","category":"macro"},{"location":"steadystate.html#HANKEstim.@make_fnaggr","page":"Steady state","title":"HANKEstim.@make_fnaggr","text":"@make_fnaggr(fn_name)\n\nCreate function fn_name that returns an instance of struct IndexStructAggr (created by @make_struct_aggr), mapping aggregate states and controls to values 1 to length(aggr_names) (both steady state and deviation from it).\n\nRequires\n\n(module) global aggr_names\n\n\n\n\n\n","category":"macro"},{"location":"steadystate.html#HANKEstim.@make_struct","page":"Steady state","title":"HANKEstim.@make_struct","text":"@makestruct(structname)\n\nMake struct struct_name with two fields for every variable name in s_names (state variables) and c_names (control variables), together with fields for distribution-states and marginal value function-controls.\n\nRequires\n\n(module) globals state_names, control_names\n\n\n\n\n\n","category":"macro"},{"location":"steadystate.html#HANKEstim.@make_struct_aggr","page":"Steady state","title":"HANKEstim.@make_struct_aggr","text":"@makestructaggr(struct_name) \n\nMake struct struct_name with two fields for every variable name in aggr_names (for steady state value and for deviation from it).\n\nRequires\n\n(module) global aggr_names\n\n\n\n\n\n","category":"macro"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"[BBL]: For details, see the paper Shocks, Frictions, and Inequality in US Business Cycles","category":"page"},{"location":"steadystate.html","page":"Steady state","title":"Steady state","text":"[BL]: For details, see the paper Solving heterogeneous agent models in discrete time with many idiosyncratic states by perturbation methods","category":"page"},{"location":"estimation.html#Estimation-of-parameters","page":"Estimation","title":"Estimation of parameters","text":"","category":"section"},{"location":"estimation.html","page":"Estimation","title":"Estimation","text":"note: Note\nMost of the code of this section is in the folder 6_Estimation","category":"page"},{"location":"estimation.html#Settings","page":"Estimation","title":"Settings","text":"","category":"section"},{"location":"estimation.html","page":"Estimation","title":"Estimation","text":"EstimationSettings","category":"page"},{"location":"estimation.html#HANKEstim.EstimationSettings","page":"Estimation","title":"HANKEstim.EstimationSettings","text":"EstimationSettings()\n\nCollect settings for the estimation of the model parameters in a struct.\n\nUse package Parameters to provide initial values. Input and output file names are stored in the fields mode_start_file, data_file, save_mode_file and save_posterior_file.\n\n\n\n\n\n","category":"type"},{"location":"estimation.html","page":"Estimation","title":"Estimation","text":"The estimation settings (globally instantiated as e_set in HANKEstim.jl) manage the following areas of the estimation:","category":"page"},{"location":"estimation.html","page":"Estimation","title":"Estimation","text":"the match between data and model: data_file is a path to a .csv-file   that contains quarterly observations of several variables (in columns), named in   observed_vars_input. Missing data is denoted by NaN. If some column-names do not align with the model   variables, data_rename is used. Level variables that should correspond to growth   rates in the data can be selected in growth_rate_select. Measurement errors   will be added for observables in meas_error_input\nestimation of variances: shock_names contain the aggregate shocks in the model,   whose variances are estimated. me_treatment defines how measurement errors   are treated: for :fixed, their variances are fixed by the data-variance, otherwise   they are estimated either with :bounded uniform priors, or :unbounded priors    (see measurement_error()). For the latter case, the priors are set in   meas_error_distr\nnumerical parameters: the maximum number of iterations to find the mode of the   likelihood (see mode_finding()) is set in max_iter_mode. ndraws, burnin   and mhscale are parameters for the Random-Walk Metropolis Hastings algorithm (see rwmh())\nestimation flags: whether to estimate the model is set in estimate_model. compute_hessian determines whether the Hessian is computed after mode finding or set to an identity matrix (see mode_finding()). multi_chain_init sets whether multiple chains in the RWMH (see rwmh()) are started from an overdispersed posterior mode. All flags are set to false by default.","category":"page"},{"location":"estimation.html#Mode-finding","page":"Estimation","title":"Mode finding","text":"","category":"section"},{"location":"estimation.html","page":"Estimation","title":"Estimation","text":"mode_finding","category":"page"},{"location":"estimation.html#HANKEstim.mode_finding","page":"Estimation","title":"HANKEstim.mode_finding","text":"mode_finding(XSSaggr, A, B, indexes, indexes_aggr, distrSS, compressionIndexes, m_par, n_par, e_set)\n\nGiven definition of observed variables and their transformation (level or growth rate) from e_set, load the data, construct the observation equation, and maximize likeli() (the log-likelihood) using the package Optim.\n\nSave estimation results to e_set.save_mode_file.\n\nReturns\n\npar_final: parameter vector that maximizes the likelihood\nhessian_final: Hessian of the log-likelihood at par_final\nposterior_mode: log-likelihood at par_final\nmeas_error,meas_error_std: returns from measurement_error()\nparnames: names of estimated parameters (including measurement error variances)\nData,Data_missing: data from e_set.data_file; marker for missing data\nH_sel: selector matrix for states/controls that are observed\npriors: priors of parameters (including measurement error variances)\n\n\n\n\n\n","category":"function"},{"location":"estimation.html","page":"Estimation","title":"Estimation","text":"The main computations are the construction of the likelihood of the model parameters and its maximization. We get the model parameters that are to be estimated, together with their priors, from m_par (in addition to measurement error variances, see Settings).","category":"page"},{"location":"estimation.html#The-likelihood-function","page":"Estimation","title":"The likelihood function","text":"","category":"section"},{"location":"estimation.html","page":"Estimation","title":"Estimation","text":"The function likeli() computes the log-likelihood of the model parameters par in the following steps:","category":"page"},{"location":"estimation.html","page":"Estimation","title":"Estimation","text":"call SGU_estim() to derive the linear state-space representation of the model given par.  Differently from SGU(), differentiate only the system of aggregate equilibrium  conditions with respect to aggregate variables, i.e. Fsys_agg(). This is sufficient,  as the estimated parameters do not enter in the heterogeneous agent part of the equilibrium system [BBL].  Then, update the derivatives A and B of the full model for aggregate variables and conditions,  and compute the observation and state transition equations as in SGU()\ndelete rows of the observation equation that correspond to unobserved controls  (the selector matrix H_sel is constructed in mode_finding()). Then, feed  the linear state-space system, the data, and the variances of the structural and  measurement shocks, into the Kalman filter (see kalman_filter()), which computes  the log-likelihood","category":"page"},{"location":"estimation.html","page":"Estimation","title":"Estimation","text":"We find the maximizer of the likelihood function, as well as its Hessian at the maximum, with the package Optim. Note that in order to obtain the Hessian, you need to set e_set.compute_hessian = true.","category":"page"},{"location":"estimation.html#Called-functions","page":"Estimation","title":"Called functions","text":"","category":"section"},{"location":"estimation.html","page":"Estimation","title":"Estimation","text":"likeli\nSGU_estim\nkalman_filter\nmeasurement_error","category":"page"},{"location":"estimation.html#HANKEstim.likeli","page":"Estimation","title":"HANKEstim.likeli","text":"likeli(par,Data,Data_miss,H_sel,XSSaggr,A,B,indexes,indexes_aggr,m_par,n_par,e_set,Copula,distrSS,compressionIndexes,priors,meas_error,meas_error_std;smoother=False)\n\nCompute the likelihood of Data, given model-parameters par and prior priors (maximize to find MLE of par).\n\nSolve model with SGU_estim(), compute likelihood with kalman_filter() or with kalman_filter_smoother() (if smoother==True).\n\nReturns\n\nif smoother==False:\n\nlog_like,prior_like,post_like,alarm: log-likelihoods (post is the sum of prior and computed likelihood); alarm indicates error when solving model with SGU_estim, sets log-likelihood to -9.e15\n\nif smoother==True:\n\nsmoother_output: returns from kalman_filter_smoother()\n\n\n\n\n\n","category":"function"},{"location":"estimation.html#HANKEstim.SGU_estim","page":"Estimation","title":"HANKEstim.SGU_estim","text":"SGU_estim(XSS,A,B,m_par,n_par,indexes_aggr,distrSS;estim)\n\nCalculate the linearized solution to the non-linear difference equations defined by function Fsys, while only differentiating with respect to the aggregate part of the model, Fsys_agg().\n\nThe partials of the Jacobian belonging to the heterogeneous agent part of the model are taken from the full-model derivatives provided as arguments, A and B (computed by SGU()).\n\nArguments\n\nXSS: steady state around which the system is linearized\nA,B: derivative of Fsys() with respect to arguments X [B] and   XPrime [A]\nm_par::ModelParameters, n_par::NumericalParameters: n_par.sol_algo determines   the solution algorithm\nindexes::IndexStruct,indexes_aggr::IndexStructAggr: access aggregate states and controls by name\ndistrSS::Array{Float64,3}: steady state joint distribution\n\nReturns\n\nas in SGU()\n\n\n\n\n\n","category":"function"},{"location":"estimation.html#HANKEstim.kalman_filter","page":"Estimation","title":"HANKEstim.kalman_filter","text":"kalman_filter(H,LOM,Data,D_miss,SCov,MCov,e_set)\n\nCompute likelihood of Data, applying the Kalman filter to the state-space represenation (H,LOM) of the model.\n\nArguments\n\nH::Array{Float64,2}: observation equation\nLOM::Array{Float64,2}: law of motion for states\nData::Array{Union{Missing,Float64},2},D_miss::BitArray{2}: data (time times variable); marker for missing data\nSCov::Array{Float64,2}: covariance of structural shocks\nMCov::Diagonal{Float64,Array{Float64,1}}: covariance of measurement error\n\nReturns\n\nlog-likelihood\n\n\n\n\n\n","category":"function"},{"location":"estimation.html#HANKEstim.measurement_error","page":"Estimation","title":"HANKEstim.measurement_error","text":"measurement_error(Data,observed_vars,e_set)\n\nBuild measurement error.\n\nArguments\n\nData: matrix of observables [nobs * nvar]\nobserved_vars: vector of observed variable names [nvar * 1]\ne_set::EstimationSettings\n\nReturns\n\nmeas_error: ordered dictionary of measurement errors linked to observables\nmeas_error_prior: corresponding priors for measurement errors\nmeas_error_std: standard deviations of observables with measurement error\n\n\n\n\n\n","category":"function"},{"location":"estimation.html#Bayesian-estimation","page":"Estimation","title":"Bayesian estimation","text":"","category":"section"},{"location":"estimation.html","page":"Estimation","title":"Estimation","text":"montecarlo","category":"page"},{"location":"estimation.html#HANKEstim.montecarlo","page":"Estimation","title":"HANKEstim.montecarlo","text":"montecarlo(mr,er;file=e_set.save_posterior_file)\n\nSample posterior of parameter vector with rwmh(), take sample mean as parameter estimate, and save all results in file.\n\nArguments\n\nsr::SteadyResults\nmr::LinearResults\ner::EstimResults\n\n\n\n\n\n","category":"function"},{"location":"estimation.html","page":"Estimation","title":"Estimation","text":"We use a Monte Carlo Markov Chain method, specifically the Random-Walk Metropolis Hastings (rwmh()) algorithm, to sample from the posterior probability distribution of the parameter vector. To obtain the posterior likelihood of each draw, we call likeli(), which evaluates the priors at par (prioreval()) and returns the log-posterior as a sum of the log-prior and the log-likelihood.","category":"page"},{"location":"estimation.html","page":"Estimation","title":"Estimation","text":"Given the draws from the posterior, we can analyze the probabilities of the parameters using the package MCMCChains. We take the average over the draws as our Bayesian estimate of the parameter vector, par_final. To obtain an estimate of the underlying state over the data sample period, we call likeli() with par_final and keyword smoother=true (this calls the Kalman smoother kalman_filter_smoother()). The result is stored in smoother_output, and saved with the other results in e_set.save_posterior_file.","category":"page"},{"location":"estimation.html#Called-functions-2","page":"Estimation","title":"Called functions","text":"","category":"section"},{"location":"estimation.html","page":"Estimation","title":"Estimation","text":"rwmh\nprioreval\nkalman_filter_smoother","category":"page"},{"location":"estimation.html#HANKEstim.rwmh","page":"Estimation","title":"HANKEstim.rwmh","text":"rwmh(xhat, Σ, n_par, Data, D_miss, H_sel, XSSaggr, A, B, indexes, indexes_aggr, m_par, e_set, Copula, distrSS, compressionIndexes, priors,meas_error, meas_error_std)\n\nSample the posterior of the parameter vector using the Random-Walk Metropolis Hastings algorithm.\n\nReturns\n\ndraws::Array{Float64,2}: e_set.ndraws + e_set.burnin sampled parameter vectors (row vectors)\nposterior: vector of posteriors for the respective draws\naccept_rate: acceptance rate\n\n\n\n\n\n","category":"function"},{"location":"estimation.html#HANKEstim.prioreval","page":"Estimation","title":"HANKEstim.prioreval","text":"prioreval(par,priors)\n\nEvaluate prior PDF at the parameters given in par.\n\nArguments\n\npar: vector of parameters [npar*1]\npriors: vector of prior distributions [npar*1]\n\nReturns\n\nlog_priorval: log prior density [scalar]\nalarm: indicator that is 1 if there is a violation of the prior bounds [scalar]\n\n\n\n\n\n","category":"function"},{"location":"estimation.html#HANKEstim.kalman_filter_smoother","page":"Estimation","title":"HANKEstim.kalman_filter_smoother","text":"kalman_filter_smoother(H,LOM,Data,D_nomiss,SCov,MCov,e_set)\n\nCompute likelihood and estimate of underlying states given the full observed Data by applying the Kalman smoother to the state-space represenation (H,LOM) of the model.\n\nArguments\n\nH::Array{Float64,2}: observation equation\nLOM::Array{Float64,2}: law of motion for states\nData::Array{Union{Missing,Float64},2},D_nomiss::BitArray{2}: data (time times variable); marker for existent data\nSCov::Array{Float64,2}: covariance of structural shocks\nMCov::Diagonal{Float64,Array{Float64,1}}: covariance of measurement error\n\nReturns\n\nlog_lik: log-likelihood\nxhat_tgt,xhat_tgT: estimate of underlying states from forward iteration [xhat_tgt] and   backward iteration [xhat_tgT]\nSigma_tgt,Sigma_tgT: estimate of covariance matrices from forward iteration [Sigma_tgt]   and backward iteration [Sigma_tgT]\ns,m: ?\n\n\n\n\n\n","category":"function"},{"location":"estimation.html","page":"Estimation","title":"Estimation","text":"[BBL]: For details, see the paper Shocks, Frictions, and Inequality in US Business Cycles","category":"page"},{"location":"index.html#HANKEstim.jl-Documentation","page":"Home","title":"HANKEstim.jl Documentation","text":"","category":"section"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This manual documents the Julia module HANKEstim, that implements the solution and Bayesian likelihood estimation of a heterogeneous-agent New-Keynesian (HANK) model. It accompanies the paper Shocks, Frictions, and Inequality in US Business Cycles.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"note: Note\nThe paper is currently under revision and the updated toolbox does not replicate the results in the linked version of the paper.","category":"page"},{"location":"index.html#First-steps","page":"Home","title":"First steps","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The module runs with Julia 1.7.1. We recommend to use Julia for VSCode IDE as a front-end to Julia. To get started with the toolbox, simply download or clone the folder, e.g. via git clone, cd to the project directory and call","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(v1.7) pkg> activate .\n\n(HANK_BusinessCycleAndInequality) pkg> instantiate","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This will install all needed packages. For more on Julia environments, see Pkg.jl.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"warning: Warning\nBefore you activate the environment, make sure that you are in the main directory, in which the Manifest.toml and Project.toml files are located. In case you accidentally activated the environment in a subfolder, empty .toml files will be created that you need to delete before proceeding in the correct folder.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For an introduction, it is easiest to use the Julia script script.jl in the src folder. Make sure that the folder is the present working directory and that the bottom bar in VSCode shows Julia env: HANK_BusinessCycleAndInequality.[1] At the top of the script file, we pre-process some user input regarding the aggregate model and the steady state (see below) and write them them into the respective functions in the folder 5_LinearizationFunctions\\generated_fcns. This has to be done before the HANKEstim module, defined in HANKEstim.jl, is loaded via","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"push!(LOAD_PATH, pwd())\nusing HANKEstim","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"# !!! note\n#\n#    Instead of pushing the current directory to `LOAD_PATH` at runtime, one can also move the folder `HANKEstim` to\n#    the place where packages are stored in the local Julia environment.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"HANKEstim.jl is the key module file as it loads in the code base, sets up structures, and exports a number of functions and macros.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The provided script.jl then shows how a typical estimation proceeds in three main steps. First, we solve the steady state of the model, and reduce the dimensionality of the state space [BL]. Secondly, we compute the linearized dynamics of the model around the steady state. Thirdly, we construct the likelihood of the model parameters given data, and use Bayesian methods to estimate them. More details on the three steps are provided in the menu on the left. script.jl also provides an example on how to plot some impulse response functions from the model.","category":"page"},{"location":"index.html#Setting-up-your-model","page":"Home","title":"Setting up your model","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"To define the aggregate part of the model, include the aggregate model block in 1_Model\\input_aggregate_model.jl. The model variables are divided into states (distribution, productivity, ...) and controls (consumption policy or marginal utilities, prices, aggregate capital stock, ...). The aggregate variables (i.e. excluding the distribution and marginal utilities) are defined  in 1_Model\\include_aggregate_names and their steady states in 1_Model\\input_aggregate_steady_state. Include model parameters in struct ModelParameters in 1_Model\\Parameters.jl.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The file Parameters.jl contains three structures to provide model parameters, numerical parameters, and estimation settings. In additon, it contains two macros that automatically create structures that contain the model variables.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The model parameters for the steady state have to be calibrated. We set them in the struct ModelParameters. It also contains all other parameters that are estimated, including the stochastic process-parameters for the aggregate shocks. Each model parameter has a line of code. It starts with the parameter name as it is used in the code and a default value. The next two entries are its ascii name and its name for LaTeX output. The fourth entry is the prior if the parameter is to be estimated. Please see the Distributions.jl-package for available options. The fifth entry is a Boolean whether the parameter should be estimated (true) or not (false)","category":"page"},{"location":"index.html#Steady-state-and-dimensionality-reduction","page":"Home","title":"Steady state and dimensionality reduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The command","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"sr = compute_steadystate(m_par)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"calls the functions find_steadystate() and prepare_linearization() and saves their returns in an instance sr of the struct SteadyResults. sr contains vectors of the steady-state variables (together with index-vectors to reference them by name), the steady-state distribution of income and assets, and devices to retrieve the full states from the compressed state vectors.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"tip: Tip\nsr may be saved to the local file system by callingHANKEstim.@save \"7_Saves/steadystate.jld2\" srand can be loaded for a future session withHANKEstim.@load \"7_Saves/steadystate.jld2\" sr","category":"page"},{"location":"index.html#Linearize-full-model","page":"Home","title":"Linearize full model","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"After computing the steady state and saving it in the SteadyResults-struct named sr,","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"lr = linearize_full_model(sr, m_par)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"computes the linear dynamics of the model around the steady state and saves a state-space representation in the instance lr of the struct LinearResults (see linearize_full_model()).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"While solving for the first-order dynamics of the full model takes a few seconds (after having been compiled, i.e. after the first run), a factorization result [BBL] makes it possible to only solve the aggregate part of the model when estimating the parameters (see SGU_estim()), which significantly reduces its computation time.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Both SGU() and SGU_estim() call SolveDiffEq() to obtain a solution to the linearized difference equation.","category":"page"},{"location":"index.html#Estimation-of-model-parameters","page":"Home","title":"Estimation of model parameters","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Having obtained SteadyResults sr and LinearResults lr, the command","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"er = find_mode(sr, lr, m_par)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"computes the mode of the likelihood, i.e. the parameter vector that maximizes the probability of observing the data given the model, and saves the results in er, an instance of struct EstimResults (see mode_finding()). We use the Kalman filter to compute the likelihood, and the package Optim for optimization. Settings for the estimation can adjusted in the struct EstimationSettings.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"warning: Warning\nBy default, the flag estimate_model in the struct EstimationSettings is set to false. Depending on the computing power available, finding the mode of the likelihood can take several hours to run through. The mode finder might also seem frozen after finishing the optimization but the computation of the Hessian for the large model is involved and can take a long time for the large model. For instructional purposes, we therefore set e_set.compute_hessian = false by default and load the Hessian from a save file. For a proper estimation, this has to be set to true. We also save an intermediate step before computing the Hessian in case you are only interested in the mode itself.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Lastly,","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"montecarlo(sr, lr, er, m_par)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"uses a Monte Carlo Markov Chain method to trace out the posterior probabilites of the estimated parameters. The final estimates (and further results) are saved in a file with the name given by the field save_posterior_file in the struct EstimationSettings (instantiated in e_set).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"note: Note\nThe module HANKEstim creates the estimation settings e_set in its main script (when it is initialized), so changes to the struct EstimationSettings are only effective before using HANKEstim. Make sure that all file paths specified in EstimationSettings are correct relative to your script's position.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[1]: If you use a different editor, make sure that the environment is correctly set, as otherwise the instantiated packages might not be found.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[BBL]: See the paper Shocks, Frictions, and Inequality in US Business Cycles","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[BL]: For a description of the solution methods applied here, see the paper Solving heterogeneous agent models in discrete time with many idiosyncratic states by perturbation methods","category":"page"}]
}
