<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linearization · Documentation for HANKEstim module</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Documentation for HANKEstim module</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="steadystate.html">Steady state</a></li><li class="is-active"><a class="tocitem" href="linearization.html">Linearization</a><ul class="internal"><li><a class="tocitem" href="#Overview-of-SGU()"><span>Overview of <code>SGU()</code></span></a></li><li><a class="tocitem" href="#Overview-of-SolveDiffEq()&#39;"><span>Overview of `SolveDiffEq()&#39;</span></a></li><li><a class="tocitem" href="#Overview-of-Fsys()"><span>Overview of <code>Fsys()</code></span></a></li></ul></li><li><a class="tocitem" href="estimation.html">Estimation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="linearization.html">Linearization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="linearization.html">Linearization</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/master/docs/src/linearization.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Linear-perturbation-around-steady-state"><a class="docs-heading-anchor" href="#Linear-perturbation-around-steady-state">Linear perturbation around steady state</a><a id="Linear-perturbation-around-steady-state-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-perturbation-around-steady-state" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The main functions of this section are in the folder <code>LinearizationFunctions</code>.</p></div></div><p>The model is linearized with respect to aggregate variables. For this, we write the equilibrium conditions in the form of <span>$F(X,X&#39;)=0$</span>, where <span>$X$</span> and <span>$X&#39;$</span> are (expected) deviations from steady state in two successive periods. Applying the total differential yields <span>$A*X&#39; = - B*X$</span>, where <span>$A$</span>,<span>$B$</span> are the first derivatives of <span>$F$</span> with respect to <span>$X&#39;$</span>,<span>$X$</span>. In the standard setting, we use the generalized Schur decomposition <sup class="footnote-reference"><a id="citeref-Klein" href="#footnote-Klein">[Klein]</a></sup> to transform this equation into a linearized observation equation <span>$d = gx*k$</span> and a linearized state transition equation <span>$k&#39; = hx*k$</span>, where <span>$k$</span> is a vector of the <em>state</em> variables and <span>$d$</span> is a vector of the <em>control</em> variables (<span>$X = \begin{bmatrix} k \\ d \end{bmatrix}$</span>).</p><p>In our code, <span>$F$</span> is implemented as <a href="linearization.html#HANKEstim.Fsys"><code>Fsys()</code></a>, while differentiating and solving for <span>$gx$</span> and <span>$hx$</span> is done in <a href="linearization.html#HANKEstim.SGU"><code>SGU()</code></a>, and <a href="linearization.html#HANKEstim.linearize_full_model"><code>linearize_full_model()</code></a> returns the results as a <code>struct</code> <code>LinearResults</code>:</p><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.linearize_full_model" href="#HANKEstim.linearize_full_model"><code>HANKEstim.linearize_full_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">linearize_full_model()</code></pre><p>Linearize the full solution (i.e. with idiosyncratic states and controls) around the steady state, using <a href="linearization.html#HANKEstim.SGU"><code>SGU()</code></a>.</p><p><strong>Returns</strong></p><p><code>struct</code> <code>LinearResults</code>, containing</p><ul><li><code>A::Array{Float64,2}</code>,<code>B::Array{Float64,2}</code>: first derivatives of <a href="linearization.html#HANKEstim.Fsys"><code>Fsys()</code></a> with respect to arguments <code>X</code> [<code>B</code>]   and <code>XPrime</code> [<code>A</code>]</li><li><code>State2Control::Array{Float64,2}</code>: observation equation</li><li><code>LOMstate::Array{Float64,2}</code>: state transition equation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/0f8eea329a16361fdb7b7095dfc7c1663e61b3bf/src/HANKEstim.jl#L78-L90">source</a></section></article><h2 id="Overview-of-SGU()"><a class="docs-heading-anchor" href="#Overview-of-SGU()">Overview of <code>SGU()</code></a><a id="Overview-of-SGU()-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-of-SGU()" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.SGU" href="#HANKEstim.SGU"><code>HANKEstim.SGU</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SGU(XSS,A,B,m_par,n_par,indexes,Copula,compressionIndexes,distrSS;estim)</code></pre><p>Calculate the linearized solution to the non-linear difference equations defined by function <a href="linearization.html#HANKEstim.Fsys"><code>Fsys()</code></a>, using Schmitt-Grohé &amp; Uribe (JEDC 2004) style linearization (apply the implicit function theorem to obtain linear observation and state transition equations).</p><p>The Jacobian is calculated using the package <code>ForwardDiff</code></p><p><strong>Arguments</strong></p><ul><li><code>XSS</code>: steady state around which the system is linearized</li><li><code>A</code>,<code>B</code>: matrices to be filled with first derivatives (see <code>Returns</code>)</li><li><code>m_par::ModelParameters</code>, <code>n_par::NumericalParameters</code>: <code>n_par.sol_algo</code> determines   the solution algorithm</li><li><code>Copula::Function</code>,<code>distrSS::Array{Float64,3}</code>: <code>Copula</code> maps marginals to   linearized approximation of joint distribution around <code>distrSS</code></li><li><code>indexes::IndexStruct</code>,<code>compressionIndexes</code>: access states and controls by name   (DCT coefficients of compressed <span>$V_m$</span> and <span>$V_k$</span> in case of   <code>compressionIndexes</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>gx</code>,<code>hx</code>: observation equations [<code>gx</code>] and state transition equations [<code>hx</code>]</li><li><code>alarm_sgu</code>,<code>nk</code>: <code>alarm_sgu=true</code> when solving algorithm fails, <code>nk</code> number of   predetermined variables</li><li><code>A</code>,<code>B</code>: first derivatives of <a href="linearization.html#HANKEstim.Fsys"><code>Fsys()</code></a> with respect to arguments <code>X</code> [<code>B</code>] and   <code>XPrime</code> [<code>A</code>]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/0f8eea329a16361fdb7b7095dfc7c1663e61b3bf/src/5_LinearizationFunctions/SGU.jl#L1-L28">source</a></section></article><p>The function executes the following steps:</p><ul><li><p>generate devices to retrieve distribution and marginal value functions from   compressed states/controls (<code>Γ</code> and <code>DC</code>,<code>IDC</code>)</p></li><li><p>calculate the first derivative of <a href="linearization.html#HANKEstim.Fsys"><code>Fsys()</code></a> with respect to <code>X</code> and <code>XPrime</code>.   We use automatic differentiation (implemented in Julia by the package <code>ForwardDiff</code>).   Partial derivatives are calculated using the <code>ForwardDiff.jacobian()</code> function.   We exploit that some partial derivatives have known values (contemporaneous marginal value   functions and the future marginal distributions) and set them directly instead of calculating them <sup class="footnote-reference"><a id="citeref-BL" href="#footnote-BL">[BL]</a></sup>.</p></li><li><p>compute linear observation and state transition equations using the <a href="linearization.html#HANKEstim.SolveDiffEq"><code>SolveDiffEq()</code></a> function</p></li></ul><h2 id="Overview-of-SolveDiffEq()&#39;"><a class="docs-heading-anchor" href="#Overview-of-SolveDiffEq()&#39;">Overview of `SolveDiffEq()&#39;</a><a id="Overview-of-SolveDiffEq()&#39;-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-of-SolveDiffEq()&#39;" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.SolveDiffEq" href="#HANKEstim.SolveDiffEq"><code>HANKEstim.SolveDiffEq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SolveDiffEq(A, B, n_par; estim)</code></pre><p>Calculate the solution to the linearized difference equations defined B x<em>t = A x</em>{t+1}.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>,<code>B</code>: matrices with first derivatives </li><li><code>n_par::NumericalParameters</code>: <code>n_par.sol_algo</code> determines   the solution algorithm, options are: <ul><li><code>lit</code>:   Linear time iteration (naive implementation, not recommended)</li><li><code>litx</code>:  Linear time iteration (improved implementation following Reiter fast if initial guess is good)</li><li><code>schur</code>: Klein&#39;s algorithm (fastest if no good initial guess is available)</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>gx</code>,<code>hx</code>: observation equations [<code>gx</code>] and state transition equations [<code>hx</code>]</li><li><code>alarm_sgu</code>,<code>nk</code>: <code>alarm_sgu=true</code> when solving algorithm fails, <code>nk</code> number of   predetermined variables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/0f8eea329a16361fdb7b7095dfc7c1663e61b3bf/src/5_LinearizationFunctions/SolveDiffEq.jl#L1-L19">source</a></section></article><ul><li>compute linear observation and state transition equations. The solution algorithm is set   in <code>n_par.sol_algo</code>, with the options <code>:schur</code> (mentioned above) and <code>:litx</code> <sup class="footnote-reference"><a id="citeref-lit" href="#footnote-lit">[lit]</a></sup>. The results are matrices that map contemporaneous states to controls [<code>gx</code>],   or contemporaneous states to future states [<code>hx</code>]</li></ul><h2 id="Overview-of-Fsys()"><a class="docs-heading-anchor" href="#Overview-of-Fsys()">Overview of <code>Fsys()</code></a><a id="Overview-of-Fsys()-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-of-Fsys()" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.Fsys" href="#HANKEstim.Fsys"><code>HANKEstim.Fsys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Fsys(X,XPrime,Xss,m_par,n_par,indexes,Γ,compressionIndexes,DC,IDC)</code></pre><p>Equilibrium error function: returns deviations from equilibrium around steady state.</p><p>Split computation into <em>Aggregate Part</em>, handled by <a href="linearization.html#HANKEstim.Fsys_agg"><code>Fsys_agg()</code></a>, and <em>Heterogeneous Agent Part</em>.</p><p><strong>Arguments</strong></p><ul><li><code>X</code>,<code>XPrime</code>: deviations from steady state in periods t [<code>X</code>] and t+1 [<code>XPrime</code>]</li><li><code>Xss</code>: states and controls in steady state</li><li><code>Γ</code>,<code>DC</code>,<code>IDC</code>: transformation matrices to retrieve marginal distributions [<code>Γ</code>] and   marginal value functions [<code>DC</code>,<code>IDC</code>] from deviations</li><li><code>indexes</code>,<code>compressionIndexes</code>: access <code>Xss</code> by variable names   (DCT coefficients of compressed <span>$V_m$</span> and <span>$V_k$</span> in case of <code>compressionIndexes</code>)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; # Solve for steady state, construct Γ,DC,IDC as in SGU()
julia&gt; Fsys(zeros(ntotal),zeros(ntotal),XSS,m_par,n_par,indexes,Γ,compressionIndexes,DC,IDC)
*ntotal*-element Array{Float64,1}:
 0.0
 0.0
 ...
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/0f8eea329a16361fdb7b7095dfc7c1663e61b3bf/src/5_LinearizationFunctions/FSYS.jl#L1-L27">source</a></section></article><p>The function <a href="linearization.html#HANKEstim.Fsys"><code>Fsys()</code></a> proceeds in the following way:</p><ol><li>set up vector <code>F</code>, that contains the errors to all equilibrium conditions. There are as many conditions  as deviations from steady state (length of <code>X</code>,<code>XPrime</code>), and conditions are indexed with  respective model variable in <code>IndexStruct</code> <code>indexes</code></li><li>generate locally all aggregate variables (for both periods) using <a href="linearization.html#HANKEstim.@generate_equations"><code>@generate_equations</code></a></li><li>construct the distributions and the marginal value functions from the steady state values  and the (compressed) deviations</li><li>write all equilibrium condition-errors with respect to <em>aggregate</em> variables to <code>F</code>, using  <a href="linearization.html#HANKEstim.Fsys_agg"><code>Fsys_agg()</code></a></li><li>compute optimal policies with <a href="steadystate.html#HANKEstim.EGM_policyupdate"><code>EGM_policyupdate()</code></a>, given  future marginal value functions, prices, and individual incomes. Infer present marginal  value functions from them (envelope theorem) and set the difference to assumed present  marginal value functions (in terms of their compressed deviation from steady state)  as equilibrium condition-errors (<em>backward iteration of the value function</em>)</li><li>compute future distribution from previous distribution and optimal asset policies. Set  difference to assumed future marginal distributions as equilibrium condition-errors  (<em>forward iteration of the distribution</em>)</li><li>compute distribution summary statistics with <a href="steadystate.html#HANKEstim.distrSummaries"><code>distrSummaries()</code></a> and write  equilibrium conditions with their respective (control) variables</li><li>return <code>F</code></li></ol><h3 id="Called-functions-/-macros"><a class="docs-heading-anchor" href="#Called-functions-/-macros">Called functions / macros</a><a id="Called-functions-/-macros-1"></a><a class="docs-heading-anchor-permalink" href="#Called-functions-/-macros" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.@generate_equations" href="#HANKEstim.@generate_equations"><code>HANKEstim.@generate_equations</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@generate_equations()</code></pre><p>Write out the expansions around steady state for all variables in <code>aggr_names</code>, i.e. generate code that reads aggregate states/controls from steady state deviations.</p><p>Equations take the form of (with variable <code>r</code> as example):</p><ul><li><code>r       = exp.(Xss[indexes.rSS] .+ X[indexes.r])</code></li><li><code>rPrime  = exp.(Xss[indexes.rSS] .+ XPrime[indexes.r])</code></li></ul><p><strong>Requires</strong></p><p>(module) global <code>aggr_names</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/0f8eea329a16361fdb7b7095dfc7c1663e61b3bf/src/2_NumericalBasics/MacroUtils.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.Fsys_agg" href="#HANKEstim.Fsys_agg"><code>HANKEstim.Fsys_agg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Fsys_agg(X,XPrime,Xss,distrSS,m_par,n_par,indexes)</code></pre><p>Return deviations from aggregate equilibrium conditions.</p><p><code>indexes</code> can be both <code>IndexStruct</code> or <code>IndexStructAggr</code>; in the latter case (which is how function is called by <a href="estimation.html#HANKEstim.SGU_estim"><code>SGU_estim()</code></a>), variable-vectors <code>X</code>,<code>XPrime</code>, and <code>Xss</code> only contain the aggregate variables of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/0f8eea329a16361fdb7b7095dfc7c1663e61b3bf/src/5_LinearizationFunctions/FSYS_agg_generated.jl#L4-L12">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Klein"><a class="tag is-link" href="#citeref-Klein">Klein</a>See the paper <a href="https://www.sciencedirect.com/science/article/pii/S0165188999000457">Using the generalized Schur form to solve a multivariate linear rational expectations model</a> by Paul Klein (JEDC 2000)</li><li class="footnote" id="footnote-BL"><a class="tag is-link" href="#citeref-BL">BL</a>Contemporaneous marginal value functions are irrelevant for optimal decisions, so its effect on other model variables is 0. Due to a rich enough set of prices, the future distribution directly only affects the Fokker-Planck equation. For details, see the paper <a href="https://cepr.org/active/publications/discussion_papers/dp.php?dpno=13071#">Solving heterogeneous agent models in discrete time with many idiosyncratic states by perturbation methods</a></li><li class="footnote" id="footnote-lit"><a class="tag is-link" href="#citeref-lit">lit</a>Invoking the Implicit Function Theorem, there exist functions <span>$g$</span> and <span>$h$</span> such that <span>$F\left(\begin{pmatrix} k \\ g(k) \end{pmatrix},\begin{pmatrix} h(k) \\ g(h(k)) \end{pmatrix}\right)=0$</span>. Totally differentiating by <span>$k$</span> yields <span>$B \begin{pmatrix}\mathbb{I}\\ Dg \end{pmatrix}+A \begin{pmatrix}\mathbb{I}\\ Dg \end{pmatrix} Dh = 0$</span>. The <code>:lit</code>-algorithm solves this equation for <span>$Dg$</span> and <span>$Dh$</span> iteratively.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="steadystate.html">« Steady state</a><a class="docs-footer-nextpage" href="estimation.html">Estimation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 4 June 2021 16:02">Friday 4 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
