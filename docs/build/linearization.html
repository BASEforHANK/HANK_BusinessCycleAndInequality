<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linearization · Documentation for HANKEstim module</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><script src="../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Documentation for HANKEstim module</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="steadystate.html">Steady state</a></li><li class="is-active"><a class="tocitem" href="linearization.html">Linearization</a><ul class="internal"><li><a class="tocitem" href="#Overview-of-SGU()"><span>Overview of <code>SGU()</code></span></a></li><li><a class="tocitem" href="#Overview-of-SolveDiffEq()&#39;"><span>Overview of `SolveDiffEq()&#39;</span></a></li><li><a class="tocitem" href="#Overview-of-Fsys()"><span>Overview of <code>Fsys()</code></span></a></li></ul></li><li><a class="tocitem" href="estimation.html">Estimation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="linearization.html">Linearization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="linearization.html">Linearization</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/master/docs/src/linearization.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Linear-perturbation-around-steady-state"><a class="docs-heading-anchor" href="#Linear-perturbation-around-steady-state">Linear perturbation around steady state</a><a id="Linear-perturbation-around-steady-state-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-perturbation-around-steady-state" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The main functions of this section are in the folder <code>5_LinearizationFunctions</code>.</p></div></div><p>The model is linearized with respect to aggregate variables. For this, we write the equilibrium conditions in the form of <span>$F(X,X&#39;)=0$</span>, where <span>$X$</span> and <span>$X&#39;$</span> are (expected) deviations from steady state in two successive periods. Applying the total differential yields <span>$A*X&#39; = - B*X$</span>, where <span>$A$</span>,<span>$B$</span> are the first derivatives of <span>$F$</span> with respect to <span>$X&#39;$</span>,<span>$X$</span>. In the standard setting, we use the generalized Schur decomposition <sup class="footnote-reference"><a id="citeref-Klein" href="#footnote-Klein">[Klein]</a></sup> to transform this equation into a linearized observation equation <span>$d = gx*k$</span> and a linearized state transition equation <span>$k&#39; = hx*k$</span>, where <span>$k$</span> is a vector of the <em>state</em> variables and <span>$d$</span> is a vector of the <em>control</em> variables (<span>$X = \begin{bmatrix} k \\ d \end{bmatrix}$</span>).</p><p>In our code, <span>$F$</span> is implemented as <a href="linearization.html#HANKEstim.Fsys"><code>HANKEstim.Fsys()</code></a>, while differentiating and solving for <span>$gx$</span> and <span>$hx$</span> is done in <a href="linearization.html#HANKEstim.SGU"><code>HANKEstim.SGU()</code></a>, and <a href="linearization.html#HANKEstim.linearize_full_model"><code>linearize_full_model()</code></a> returns the results as a <code>struct</code> <code>LinearResults</code>:</p><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.linearize_full_model" href="#HANKEstim.linearize_full_model"><code>HANKEstim.linearize_full_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">linearize_full_model()</code></pre><p>Linearize the full model (i.e. including idiosyncratic states and controls) around the steady state, and solves using <a href="linearization.html#HANKEstim.SGU"><code>SGU()</code></a>.</p><p><strong>Returns</strong></p><p><code>struct</code> <code>LinearResults</code>, containing</p><ul><li><code>A::Array{Float64,2}</code>,<code>B::Array{Float64,2}</code>: first derivatives of <a href="linearization.html#HANKEstim.Fsys"><code>Fsys()</code></a> with respect to arguments <code>X</code> [<code>B</code>]   and <code>XPrime</code> [<code>A</code>]</li><li><code>State2Control::Array{Float64,2}</code>: observation equation</li><li><code>LOMstate::Array{Float64,2}</code>: state transition equation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/a685d5d6cfb43934dc694612d246465dc705cc5a/src/HANKEstim.jl#L84-L96">source</a></section></article><h2 id="Overview-of-SGU()"><a class="docs-heading-anchor" href="#Overview-of-SGU()">Overview of <code>SGU()</code></a><a id="Overview-of-SGU()-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-of-SGU()" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.SGU" href="#HANKEstim.SGU"><code>HANKEstim.SGU</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">SGU(sr, m_par, A, B; estim)</code></pre><p>Calculate the linearized solution to the non-linear difference equations defined by function <a href="linearization.html#HANKEstim.Fsys"><code>Fsys()</code></a>, using Schmitt-Grohé &amp; Uribe (JEDC 2004) style linearization (apply the implicit function theorem to obtain linear observation and state transition equations).</p><p>The Jacobian is calculated using the package <code>ForwardDiff</code></p><p><strong>Arguments</strong></p><ul><li><code>sr</code>: steady-state structure (variable values, indexes, numerical parameters, ...)</li><li><code>A</code>,<code>B</code>: derivative of <a href="linearization.html#HANKEstim.Fsys"><code>Fsys()</code></a> with respect to arguments <code>X</code> [<code>B</code>] and   <code>XPrime</code> [<code>A</code>]</li><li><code>m_par</code>: model parameters</li></ul><p><strong>Returns</strong></p><ul><li><code>gx</code>,<code>hx</code>: observation equations [<code>gx</code>] and state transition equations [<code>hx</code>]</li><li><code>alarm_sgu</code>,<code>nk</code>: <code>alarm_sgu=true</code> when solving algorithm fails, <code>nk</code> number of   predetermined variables</li><li><code>A</code>,<code>B</code>: first derivatives of <a href="linearization.html#HANKEstim.Fsys"><code>Fsys()</code></a> with respect to arguments <code>X</code> [<code>B</code>] and   <code>XPrime</code> [<code>A</code>]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/a685d5d6cfb43934dc694612d246465dc705cc5a/src/5_LinearizationFunctions/SGU.jl#L1-L23">source</a></section></article><p>The function executes the following steps:</p><ul><li><p>generate devices to retrieve distribution and marginal value functions from   compressed states/controls (<code>Γ</code> and <code>DC</code>,<code>IDC</code>)</p></li><li><p>calculate the first derivative of <a href="linearization.html#HANKEstim.Fsys"><code>HANKEstim.Fsys()</code></a> with respect to <code>X</code> and <code>XPrime</code>.   We use automatic differentiation (implemented in Julia by the package <code>ForwardDiff</code>).   Partial derivatives are calculated using the <code>ForwardDiff.jacobian()</code> function.   We exploit that some partial derivatives have known values (contemporaneous marginal value   functions and the future marginal distributions) and set them directly instead of calculating them <sup class="footnote-reference"><a id="citeref-BL" href="#footnote-BL">[BL]</a></sup>.</p></li><li><p>compute linear observation and state transition equations using the <a href="linearization.html#HANKEstim.SolveDiffEq"><code>HANKEstim.SolveDiffEq()</code></a> function</p></li></ul><h2 id="Overview-of-SolveDiffEq()&#39;"><a class="docs-heading-anchor" href="#Overview-of-SolveDiffEq()&#39;">Overview of `SolveDiffEq()&#39;</a><a id="Overview-of-SolveDiffEq()&#39;-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-of-SolveDiffEq()&#39;" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.SolveDiffEq" href="#HANKEstim.SolveDiffEq"><code>HANKEstim.SolveDiffEq</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">SolveDiffEq(A, B, n_par; estim)</code></pre><p>Calculate the solution to the linearized difference equations defined as P&#39;<em>B</em>P x<em>t = P&#39;<em>A</em>P x</em>{t+1}, where <code>P</code> is the (ntotal x r) semi-unitary model reduction matrix <code>n_par.PRightAll</code> of potentially reduced rank r.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>,<code>B</code>: matrices with first derivatives </li><li><code>n_par::NumericalParameters</code>: <code>n_par.sol_algo</code> determines   the solution algorithm, options are: <ul><li><code>litx</code>:  Linear time iteration (implementation follows Reiter)</li><li><code>schur</code>: Klein&#39;s algorithm (preferable if number of controls is small)</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>gx</code>,<code>hx</code>: observation equations [<code>gx</code>] and state transition equations [<code>hx</code>]</li><li><code>alarm_sgu</code>,<code>nk</code>: <code>alarm_sgu=true</code> when solving algorithm fails, <code>nk</code> number of   predetermined variables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/a685d5d6cfb43934dc694612d246465dc705cc5a/src/5_LinearizationFunctions/SolveDiffEq.jl#L1-L19">source</a></section></article><ul><li>compute linear observation and state transition equations. The solution algorithm is set   in <code>n_par.sol_algo</code>, with the options <code>:schur</code> (mentioned above) and <code>:litx</code> <sup class="footnote-reference"><a id="citeref-lit" href="#footnote-lit">[lit]</a></sup>. The results are matrices that map contemporaneous states to controls [<code>gx</code>],   or contemporaneous states to future states [<code>hx</code>]</li></ul><h2 id="Overview-of-Fsys()"><a class="docs-heading-anchor" href="#Overview-of-Fsys()">Overview of <code>Fsys()</code></a><a id="Overview-of-Fsys()-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-of-Fsys()" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.Fsys" href="#HANKEstim.Fsys"><code>HANKEstim.Fsys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Fsys(X, XPrime, Xss, m_par, n_par, indexes, Γ, compressionIndexes, DC, IDC, DCD, IDCD)</code></pre><p>Equilibrium error function: returns deviations from equilibrium around steady state.</p><p>Split computation into <em>Aggregate Part</em>, handled by <a href="linearization.html#HANKEstim.Fsys_agg"><code>Fsys_agg()</code></a>, and <em>Heterogeneous Agent Part</em>.</p><p><strong>Arguments</strong></p><ul><li><code>X</code>,<code>XPrime</code>: deviations from steady state in periods t [<code>X</code>] and t+1 [<code>XPrime</code>]</li><li><code>Xss</code>: states and controls in steady state</li><li><code>Γ</code>, <code>DC</code>, <code>IDC</code>, <code>DCD</code>,<code>IDCD</code>: transformation matrices to retrieve marginal distributions [<code>Γ</code>],   marginal value functions [<code>DC</code>,<code>IDC</code>], and the (linear) interpolant of the copula [<code>DCD</code>,<code>IDCD</code>] from deviations</li><li><code>indexes</code>,<code>compressionIndexes</code>: access <code>Xss</code> by variable names   (DCT coefficients of compressed <span>$V_m$</span> and <span>$V_k$</span> in case of <code>compressionIndexes</code>)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; # Solve for steady state, construct Γ,DC,IDC as in SGU()
julia&gt; Fsys(zeros(ntotal),zeros(ntotal),XSS,m_par,n_par,indexes,Γ,compressionIndexes,DC,IDC)
*ntotal*-element Array{Float64,1}:
 0.0
 0.0
 ...
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/a685d5d6cfb43934dc694612d246465dc705cc5a/src/5_LinearizationFunctions/FSYS.jl#L1-L27">source</a></section></article><p>The function <a href="linearization.html#HANKEstim.Fsys"><code>HANKEstim.Fsys()</code></a> proceeds in the following way:</p><ol><li>set up vector <code>F</code>, that contains the errors to all equilibrium conditions. There are as many conditions  as deviations from steady state (length of <code>X</code>,<code>XPrime</code>), and conditions are indexed with  respective model variable in <code>IndexStruct</code> <code>indexes</code></li><li>generate locally all aggregate variables (for both periods) using <a href="linearization.html#HANKEstim.@generate_equations"><code>@generate_equations</code></a></li><li>construct the full-grid marginal distributions, marginal value functions, and the copula  from the steady-state values and the (compressed) deviations (for the copula, the selection of DCT  coefficients that can be perturbed ensures that also the perturbed function is a copula)</li><li>write all equilibrium condition-errors with respect to <em>aggregate</em> variables to <code>F</code>, using  <a href="linearization.html#HANKEstim.Fsys_agg"><code>HANKEstim.Fsys_agg()</code></a></li><li>compute optimal policies with <a href="steadystate.html#HANKEstim.EGM_policyupdate"><code>HANKEstim.EGM_policyupdate()</code></a>, given  future marginal value functions, prices, and individual incomes. Infer present marginal  value functions from them (envelope theorem) and set the difference to assumed present  marginal value functions (in terms of their compressed deviation from steady state)  as equilibrium condition-errors (<em>backward iteration of the value function</em>)</li><li>compute future marginal distributions and the copula (on the copula grid) from previous distribution and optimal asset policies. Interpolate when necessary. Set difference to assumed future marginal distributions and copula values on the copula nodes as equilibrium condition-errors (<em>forward iteration of the distribution</em>)</li><li>compute distribution summary statistics with <a href="steadystate.html#HANKEstim.distrSummaries"><code>HANKEstim.distrSummaries()</code></a> and write  equilibrium conditions with their respective (control) variables</li><li>return <code>F</code></li></ol><p>Note that the copula is treated as the sum of two interpolants. An interpolant based on the steady-state distribution using the full steady-state marginals as a grid and a &quot;deviations&quot;-function that is defined on the copula grid generated in <code>prepare_linearization()</code>. The actual interpolation is carried out with <a href="linearization.html#HANKEstim.myinterpolate3"><code>HANKEstim.myinterpolate3()</code></a>. Default setting is trilinear interpolation, the code also allows for 3d-Akima interpolation.</p><h3 id="Called-functions-/-macros"><a class="docs-heading-anchor" href="#Called-functions-/-macros">Called functions / macros</a><a id="Called-functions-/-macros-1"></a><a class="docs-heading-anchor-permalink" href="#Called-functions-/-macros" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.@generate_equations" href="#HANKEstim.@generate_equations"><code>HANKEstim.@generate_equations</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@generate_equations()</code></pre><p>Write out the expansions around steady state for all variables in <code>aggr_names</code>, i.e. generate code that reads aggregate states/controls from steady state deviations.</p><p>Equations take the form of (with variable <code>r</code> as example):</p><ul><li><code>r       = exp.(Xss[indexes.rSS] .+ X[indexes.r])</code></li><li><code>rPrime  = exp.(Xss[indexes.rSS] .+ XPrime[indexes.r])</code></li></ul><p><strong>Requires</strong></p><p>(module) global <code>aggr_names</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/a685d5d6cfb43934dc694612d246465dc705cc5a/src/3_NumericalBasics/MacroUtils.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.Fsys_agg" href="#HANKEstim.Fsys_agg"><code>HANKEstim.Fsys_agg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Fsys_agg(X, XPrime, Xss, distrSS, m_par, n_par, indexes)</code></pre><p>Return deviations from aggregate equilibrium conditions.</p><p><code>indexes</code> can be both <code>IndexStruct</code> or <code>IndexStructAggr</code>; in the latter case (which is how function is called by <a href="estimation.html#HANKEstim.SGU_estim"><code>SGU_estim()</code></a>), variable-vectors <code>X</code>,<code>XPrime</code>, and <code>Xss</code> only contain the aggregate variables of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/a685d5d6cfb43934dc694612d246465dc705cc5a/src/5_LinearizationFunctions/generated_fcns/FSYS_agg_generated.jl#L6-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.myinterpolate3" href="#HANKEstim.myinterpolate3"><code>HANKEstim.myinterpolate3</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">myinterpolate3(xgrd1, xgrd2, xgrd3, ygrd, xeval1, xeval2, xeval3)</code></pre><p>Trilineary project <code>ygrd</code> on (<code>xgrd1</code>,<code>xgrd2</code>,<code>xgrd3</code>) and use it to interpolate value at (<code>xeval1</code>,<code>xeval2</code>,<code>xeval3</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; xgrd = [1.0,6.0];
julia&gt; f((x,y,z)) = x+y+z;
julia&gt; ygrd = f.(collect(Iterators.product(xgrid,xgrid,xgrid));
julia&gt; xeval = [3.0,5.0];
julia&gt; mylinearinterpolate3(xgrd,xgrd,xgrd,ygrd,xeval,xeval,xeval)
2x2x2 Array{Float64,3}:
[:,:,1] =
 9.0 11.0
11.0 13.0
[:,:,2] =
11.0 13.0
13.0 15.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/a685d5d6cfb43934dc694612d246465dc705cc5a/src/3_NumericalBasics/LinInterpols.jl#L1-L22">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Klein"><a class="tag is-link" href="#citeref-Klein">Klein</a>See the paper <a href="https://www.sciencedirect.com/science/article/pii/S0165188999000457">Using the generalized Schur form to solve a multivariate linear rational expectations model</a> by Paul Klein (JEDC 2000)</li><li class="footnote" id="footnote-BL"><a class="tag is-link" href="#citeref-BL">BL</a>Contemporaneous marginal value functions are irrelevant for optimal decisions, so its effect on other model variables is 0. Due to a rich enough set of prices, the future distribution directly only affects the Fokker-Planck equation. For details, see the paper <a href="https://cepr.org/active/publications/discussion_papers/dp.php?dpno=13071#">Solving heterogeneous agent models in discrete time with many idiosyncratic states by perturbation methods</a></li><li class="footnote" id="footnote-lit"><a class="tag is-link" href="#citeref-lit">lit</a>Invoking the Implicit Function Theorem, there exist functions <span>$g$</span> and <span>$h$</span> such that <span>$F\left(\begin{pmatrix} k \\ g(k) \end{pmatrix},\begin{pmatrix} h(k) \\ g(h(k)) \end{pmatrix}\right)=0$</span>. Totally differentiating by <span>$k$</span> yields <span>$B \begin{pmatrix}\mathbb{I}\\ Dg \end{pmatrix}+A \begin{pmatrix}\mathbb{I}\\ Dg \end{pmatrix} Dh = 0$</span>. The <code>:lit</code>-algorithm solves this equation for <span>$Dg$</span> and <span>$Dh$</span> iteratively.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="steadystate.html">« Steady state</a><a class="docs-footer-nextpage" href="estimation.html">Estimation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Sunday 30 January 2022 16:58">Sunday 30 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
