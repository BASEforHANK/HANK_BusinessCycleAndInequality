<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Steady state · Documentation for HANKEstim module</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Documentation for HANKEstim module</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li class="is-active"><a class="tocitem" href="steadystate.html">Steady state</a><ul class="internal"><li><a class="tocitem" href="#Overview-of-find_steadystate"><span>Overview of <code>find_steadystate</code></span></a></li><li><a class="tocitem" href="#Overview-of-prepare_linearization"><span>Overview of <code>prepare_linearization</code></span></a></li><li><a class="tocitem" href="#Parameters"><span>Parameters</span></a></li><li><a class="tocitem" href="#Find-stationary-equilibrium:-functions"><span>Find stationary equilibrium: functions</span></a></li><li><a class="tocitem" href="#Dimensionality-reduction:-functions"><span>Dimensionality reduction: functions</span></a></li><li><a class="tocitem" href="#Collect-variables:-macros"><span>Collect variables: macros</span></a></li></ul></li><li><a class="tocitem" href="linearization.html">Linearization</a></li><li><a class="tocitem" href="estimation.html">Estimation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="steadystate.html">Steady state</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="steadystate.html">Steady state</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/master/docs/src/steadystate.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Computation-of-the-steady-state-and-dimensionality-reduction"><a class="docs-heading-anchor" href="#Computation-of-the-steady-state-and-dimensionality-reduction">Computation of the steady state and dimensionality reduction</a><a id="Computation-of-the-steady-state-and-dimensionality-reduction-1"></a><a class="docs-heading-anchor-permalink" href="#Computation-of-the-steady-state-and-dimensionality-reduction" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Most of the code of this section is in the folder <code>4_HetAgentsFcns</code>.</p></div></div><p>The model features uninsured income shocks <span>$y$</span> (by assumption, all workers supply the same efficiency units of labor <sup class="footnote-reference"><a id="citeref-BBL" href="#footnote-BBL">[BBL]</a></sup>, so idiosyncratic productivity shocks translate to income shocks) and two assets, bonds <span>$m$</span> and illiquid capital <span>$k$</span>. Entrepreneurs (last income-state) receive no labor income, but firm profits, while workers additionally receive labor union profits.                                                                                                </p><p>The steady state equilibrium contains marginal value functions <span>$V_m$</span> and <span>$V_k$</span> on a three-dimensional grid <span>$(m \times k \times y)$</span> and the ergodic joint distribution over these idiosyncratic states. We do dimensionality reduction <sup class="footnote-reference"><a id="citeref-BL" href="#footnote-BL">[BL]</a></sup> by applying the Discrete Cosine Transformation to the marginal value functions and approximating the joint distribution with a copula and state-dependent marginals.</p><p>The main functions are <a href="steadystate.html#HANKEstim.find_steadystate"><code>find_steadystate()</code></a> and <a href="steadystate.html#HANKEstim.prepare_linearization"><code>prepare_linearization()</code></a>:</p><h2 id="Overview-of-find_steadystate"><a class="docs-heading-anchor" href="#Overview-of-find_steadystate">Overview of <code>find_steadystate</code></a><a id="Overview-of-find_steadystate-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-of-find_steadystate" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.find_steadystate" href="#HANKEstim.find_steadystate"><code>HANKEstim.find_steadystate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_steadystate(m_par)</code></pre><p>Find the stationary equilibrium capital stock.</p><p><strong>Returns</strong></p><ul><li><code>KSS</code>: steady-state capital stock</li><li><code>VmSS</code>, <code>VkSS</code>: marginal value functions</li><li><code>distrSS::Array{Float64,3}</code>: steady-state distribution of idiosyncratic states, computed by <a href="steadystate.html#HANKEstim.Ksupply"><code>Ksupply()</code></a></li><li><code>n_par::NumericalParameters</code>,<code>m_par::ModelParameters</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/fb44c9aadd0864c7232568c1fd7cd5e91356423d/src/4_HetAgentsFcns/find_steadystate.jl#L1-L11">source</a></section></article><p>The function takes the parameter <code>struct</code> <code>ModelParameters</code> as input <code>m_par</code> (see <a href="steadystate.html#Parameters">Parameters</a>).</p><p>To find the stationary equilibrium, we proceed in roughly the following steps:</p><ol><li>instantiate the parameter <code>struct</code> <code>NumericalParameters</code> as <code>n_par</code> (see <a href="steadystate.html#Parameters">Parameters</a>). Within the struct, we set the number of income states [<code>ny</code>] and use the <a href="steadystate.html#HANKEstim.Tauchen"><code>Tauchen()</code></a> method to obtain a grid and a transition matrix of income, given the autocorrelation of the income process [<code>m_par.ρ_h</code>]. Then, include entrepreneurial state.</li><li>find equilibrium capital stock (by finding a root of <a href="steadystate.html#HANKEstim.Kdiff"><code>Kdiff()</code></a>), where  the supply of capital by households is calculated in <a href="steadystate.html#HANKEstim.Ksupply"><code>Ksupply()</code></a>,  which uses the Endogenous Grid Method (see <a href="steadystate.html#HANKEstim.EGM_policyupdate"><code>EGM_policyupdate</code></a>)  to iteratively obtain optimal policies and marginal value functions</li></ol><h2 id="Overview-of-prepare_linearization"><a class="docs-heading-anchor" href="#Overview-of-prepare_linearization">Overview of <code>prepare_linearization</code></a><a id="Overview-of-prepare_linearization-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-of-prepare_linearization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.prepare_linearization" href="#HANKEstim.prepare_linearization"><code>HANKEstim.prepare_linearization</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prepare_linearization(KSS, VmSS, VkSS, distrSS, n_par, m_par)</code></pre><p>Compute a number of equilibrium objects needed for linearization.</p><p><strong>Arguments</strong></p><ul><li><code>KSS</code>: steady-state capital stock</li><li><code>VmSS</code>, <code>VkSS</code>: marginal value functions</li><li><code>distrSS::Array{Float64,3}</code>: steady-state distribution of idiosyncratic states, computed by <a href="steadystate.html#HANKEstim.Ksupply"><code>Ksupply()</code></a></li><li><code>n_par::NumericalParameters</code>,<code>m_par::ModelParameters</code></li></ul><p><strong>Returns</strong></p><ul><li><code>XSS::Array{Float64,1}</code>, <code>XSSaggr::Array{Float64,1}</code>: steady state vectors produced by <a href="steadystate.html#HANKEstim.@writeXSS"><code>@writeXSS()</code></a></li><li><code>indexes</code>, <code>indexes_aggr</code>: <code>struct</code>s for accessing <code>XSS</code>,<code>XSSaggr</code> by variable names, produced by <a href="steadystate.html#HANKEstim.@make_fn"><code>@make_fn()</code></a>,       <a href="steadystate.html#HANKEstim.@make_fnaggr"><code>@make_fnaggr()</code></a></li><li><code>compressionIndexes::Array{Array{Int,1},1}</code>: indexes for compressed marginal value functions (<span>$V_m$</span> and <span>$V_k$</span>)</li><li><code>Copula(x,y,z)</code>: function that maps marginals <code>x</code>,<code>y</code>,<code>z</code> to approximated joint distribution, produced by       <a href="steadystate.html#HANKEstim.mylinearinterpolate3"><code>mylinearinterpolate3()</code></a></li><li><code>n_par::NumericalParameters</code>,<code>m_par::ModelParameters</code></li><li><code>CDF_SS</code>, <code>CDF_m</code>, <code>CDF_k</code>, <code>CDF_y</code>: cumulative distribution functions (joint and marginals)</li><li><code>distrSS::Array{Float64,3}</code>: steady state distribution of idiosyncratic states, computed by <a href="steadystate.html#HANKEstim.Ksupply"><code>Ksupply()</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/fb44c9aadd0864c7232568c1fd7cd5e91356423d/src/5_LinearizationFunctions/generated_fcns/prepare_linearization_generated.jl#L5-L26">source</a></section></article><p>We first calculate other equilibrium quantities and produce distributional summary statistics (<a href="steadystate.html#HANKEstim.distrSummaries"><code>distrSummaries()</code></a>). Next, we reduce the dimensionality:</p><ol><li>compute coefficients of the Chebyshev polynomials that serve as basis functions  for <span>$V_m$</span> and <span>$V_k$</span>, using the Discrete Cosine Transformation (Julia-package  <code>FFTW</code>), and retain those that explain the most of its variance, up to   <code>100*(1-n_par.reduc)</code> percent. Save their indices in <code>compressionIndexes</code></li><li>compute the Copula as a function that maps three marginal  distributions to a linear interpolation of the joint distribution on its  marginals (see <a href="steadystate.html#HANKEstim.mylinearinterpolate3"><code>mylinearinterpolate3()</code></a>)</li></ol><p>Lastly, we collect the steady state values of all model variables in the  vector <code>XSS</code> (see <a href="steadystate.html#HANKEstim.@writeXSS"><code>@writeXSS</code></a>). The <em>state</em> variables consist of the marginal distributions over <span>$m$</span>, <span>$k$</span> and <span>$y$</span> and the aggregate state variables (collected in <code>state_names</code>). The <em>control</em> variables consist of the steady state marginal value functions (over the full grid) and the aggregate control variables (collected in <code>control_names</code>; these vectors are defined in the main script <code>HANKEstim.jl</code>).</p><p>While the steady state marginal value functions have full dimensionality, in the vectors that collect <em>deviations</em> from steady state (in <a href="linearization.html#HANKEstim.Fsys"><code>Fsys()</code></a>, those are <code>X</code> and <code>XPrime</code>) only the coefficients of the most important Chebyshev polynomials are saved. Additionally, the deviations of the marginal distributions are saved with one entry short of the grid size, since the marginals are restricted to sum up to 1. We manage this by creating the <code>struct</code> <code>indexes</code> (using <a href="steadystate.html#HANKEstim.@make_fn"><code>@make_fn</code></a>), that has two fields for each variable: steady state value and deviation.</p><p>We also construct the vector <code>XSSaggr</code> and the <code>struct</code> <code>indexes_aggr</code>, which are similar to the above but only store (and manage) aggregate variables. This is useful for differentiating only with respect to aggregate variables in the estimation part (see <a href="estimation.html#HANKEstim.SGU_estim"><code>SGU_estim()</code></a>).</p><h2 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h2><p>The model parameters for the steady state have to be calibrated. We set them in the <code>struct</code> <code>ModelParameters</code>. It also contains all other parameters that are estimated, including the stochastic process-parameters for the aggregate shocks.</p><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.ModelParameters" href="#HANKEstim.ModelParameters"><code>HANKEstim.ModelParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ModelParameters()</p><p>Collect all model parameters with calibrated values / priors for estimation in a <code>struct</code>.</p><p>Uses packages <code>Parameters</code>, <code>FieldMetadata</code>, <code>Flatten</code>. Boolean value denotes whether parameter is estimated.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m_par = ModelParameters();
julia&gt; # Obtain vector of prior distributions of parameters that are estimated.
julia&gt; priors = collect(metaflatten(m_par, prior))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/fb44c9aadd0864c7232568c1fd7cd5e91356423d/src/1_Model/Parameters.jl#L4-L18">source</a></section></article><p>The numerical parameters contain the grid (and the meshes) on which the stationary equilibrium is solved, discretization results of <a href="steadystate.html#HANKEstim.find_steadystate"><code>find_steadystate()</code></a>  like the transition matrix of income and the joint distribution, and other parameters that determine the numerical approximation or solution technique, like <code>reduc</code> or <code>sol_algo</code>.</p><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.NumericalParameters" href="#HANKEstim.NumericalParameters"><code>HANKEstim.NumericalParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><p>NumericalParameters()</p><p>Collect parameters for the numerical solution of the model in a <code>struct</code>.</p><p>Use package <code>Parameters</code> to provide initial values.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; n_par = NumericalParameters(mmin = -6.6, mmax = 1000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/fb44c9aadd0864c7232568c1fd7cd5e91356423d/src/1_Model/Parameters.jl#L105-L116">source</a></section></article><h2 id="Find-stationary-equilibrium:-functions"><a class="docs-heading-anchor" href="#Find-stationary-equilibrium:-functions">Find stationary equilibrium: functions</a><a id="Find-stationary-equilibrium:-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Find-stationary-equilibrium:-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.Tauchen" href="#HANKEstim.Tauchen"><code>HANKEstim.Tauchen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Tauchen(rho,N,sigma,mue)</code></pre><p>Generate a discrete approximation to an AR(1) process, following Tauchen (1987).</p><p>Uses importance sampling: each bin has probability 1/N to realize</p><p><strong>Arguments</strong></p><ul><li><code>rho</code>: autocorrelation coefficient</li><li><code>N</code>: number of gridpoints</li><li><code>sigma</code>: long-run variance</li><li><code>mue</code>: mean of the AR(1) process</li></ul><p><strong>Returns</strong></p><ul><li><code>grid_vec</code>: state vector grid</li><li><code>P</code>: transition matrix</li><li><code>bounds</code>: bin bounds</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/fb44c9aadd0864c7232568c1fd7cd5e91356423d/src/3_NumericalBasics/MarkovChain.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.Kdiff" href="#HANKEstim.Kdiff"><code>HANKEstim.Kdiff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Kdiff(K_guess,n_par,m_par)</code></pre><p>Calculate the difference between the capital stock that is assumed and the capital stock that prevails under that guessed capital stock&#39;s implied prices when households face idiosyncratic income risk (Aiyagari model).</p><p>Requires global functions <code>employment(K,A,m_par)</code>, <code>interest(K,A,N,m_par)</code>, <code>wage(K,A,N,m_par)</code>, <code>output(K,TFP,N,m_par)</code>, and <a href="steadystate.html#HANKEstim.Ksupply"><code>Ksupply()</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>K_guess::Float64</code>: capital stock guess</li><li><code>n_par::NumericalParameters</code>, <code>m_par::ModelParameters</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/fb44c9aadd0864c7232568c1fd7cd5e91356423d/src/4_HetAgentsFcns/IM_fcns/fcn_kdiff.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.Ksupply" href="#HANKEstim.Ksupply"><code>HANKEstim.Ksupply</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Ksupply(RB_guess,R_guess,w_guess,profit_guess,n_par,m_par)</code></pre><p>Calculate the aggregate savings when households face idiosyncratic income risk.</p><p>Idiosyncratic state is tuple <span>$(m,k,y)$</span>, where <span>$m$</span>: liquid assets, <span>$k$</span>: illiquid assets, <span>$y$</span>: labor income</p><p><strong>Arguments</strong></p><ul><li><code>R_guess</code>: real interest rate illiquid assets</li><li><code>RB_guess</code>: nominal rate on liquid assets</li><li><code>w_guess</code>: wages</li><li><code>profit_guess</code>: profits</li><li><code>n_par::NumericalParameters</code></li><li><code>m_par::ModelParameters</code></li></ul><p><strong>Returns</strong></p><ul><li><code>K</code>,<code>B</code>: aggregate saving in illiquid (<code>K</code>) and liquid (<code>B</code>) assets</li><li><code>TransitionMat</code>,<code>TransitionMat_a</code>,<code>TransitionMat_n</code>: <code>sparse</code> transition matrices   (average, with [<code>a</code>] or without [<code>n</code>] adjustment of illiquid asset)</li><li><code>distr</code>: ergodic steady state of <code>TransitionMat</code></li><li><code>c_a_star</code>,<code>m_a_star</code>,<code>k_a_star</code>,<code>c_n_star</code>,<code>m_n_star</code>: optimal policies for   consumption [<code>c</code>], liquid [<code>m</code>] and illiquid [<code>k</code>] asset, with [<code>a</code>] or   without [<code>n</code>] adjustment of illiquid asset</li><li><code>V_m</code>,<code>V_k</code>: marginal value functions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/fb44c9aadd0864c7232568c1fd7cd5e91356423d/src/4_HetAgentsFcns/IM_fcns/fcn_ksupply.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.EGM_policyupdate" href="#HANKEstim.EGM_policyupdate"><code>HANKEstim.EGM_policyupdate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">EGM_policyupdate(EVm,EVk,Qminus,πminus,RBminus,Tshock,inc,n_par,m_par,warnme)</code></pre><p>Find optimal policies, given marginal continuation values <code>EVm</code>, <code>EVk</code>, today&#39;s prices [<code>Qminus</code>, <code>πminus</code>,<code>RBminus</code>], and income [<code>inc</code>], using the Endogenous Grid Method.</p><p>Optimal policies are defined on the fixed grid, but optimal asset choices (<code>m</code> and <code>k</code>) are off-grid values.</p><p><strong>Returns</strong></p><ul><li><code>c_a_star</code>,<code>m_a_star</code>,<code>k_a_star</code>,<code>c_n_star</code>,<code>m_n_star</code>: optimal (on-grid) policies for   consumption [<code>c</code>], liquid [<code>m</code>] and illiquid [<code>k</code>] asset, with [<code>a</code>] or   without [<code>n</code>] adjustment of illiquid asset</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/fb44c9aadd0864c7232568c1fd7cd5e91356423d/src/4_HetAgentsFcns/EGM/EGM_policyupdate.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.distrSummaries" href="#HANKEstim.distrSummaries"><code>HANKEstim.distrSummaries</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distrSummaries(distr,c_a_star,c_n_star,n_par,inc,incgross,m_par)</code></pre><p>Compute distributional summary statistics, e.g. Gini indexes, top-10% income and wealth shares, and 10%, 50%, and 90%-consumption quantiles.</p><p><strong>Arguments</strong></p><ul><li><code>distr</code>: joint distribution over bonds, capital and income <span>$(m \times k \times y)$</span></li><li><code>c_a_star</code>,<code>c_n_star</code>: optimal consumption policies with [<code>a</code>] or without [<code>n</code>]   capital adjustment</li><li><code>n_par::NumericalParameters</code>, <code>m_par::ModelParameters</code></li><li><code>inc</code>: vector of (on grid-)incomes, consisting of labor income (scaled by <span>$\frac{\gamma-\tau^P}{1+\gamma}$</span>, plus labor union-profits),   rental income, liquid asset income, capital liquidation income,   labor income (scaled by <span>$\frac{1-\tau^P}{1+\gamma}$</span>, without labor union-profits),   and labor income (without scaling or labor union-profits)</li><li><code>incgross</code>: vector of (on grid-) <em>pre-tax</em> incomes, consisting of   labor income (without scaling, plus labor union-profits), rental income,   liquid asset income, capital liquidation income,   labor income (without scaling or labor union-profits)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/fb44c9aadd0864c7232568c1fd7cd5e91356423d/src/4_HetAgentsFcns/basic_fcns.jl#L14-L33">source</a></section></article><h2 id="Dimensionality-reduction:-functions"><a class="docs-heading-anchor" href="#Dimensionality-reduction:-functions">Dimensionality reduction: functions</a><a id="Dimensionality-reduction:-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Dimensionality-reduction:-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.mylinearinterpolate3" href="#HANKEstim.mylinearinterpolate3"><code>HANKEstim.mylinearinterpolate3</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mylinearinterpolate3(xgrd1,xgrd2,xgrd3,ygrd,xeval1,xeval2,xeval3)</code></pre><p>Trilineary project <code>ygrd</code> on (<code>xgrd1</code>,<code>xgrd2</code>,<code>xgrd3</code>) and use it to interpolate value at (<code>xeval1</code>,<code>xeval2</code>,<code>xeval3</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; xgrd = [1.0,6.0];
julia&gt; f((x,y,z)) = x+y+z;
julia&gt; ygrd = f.(collect(Iterators.product(xgrid,xgrid,xgrid));
julia&gt; xeval = [3.0,5.0];
julia&gt; mylinearinterpolate3(xgrd,xgrd,xgrd,ygrd,xeval,xeval,xeval)
2x2x2 Array{Float64,3}:
[:,:,1] =
 9.0 11.0
11.0 13.0
[:,:,2] =
11.0 13.0
13.0 15.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/fb44c9aadd0864c7232568c1fd7cd5e91356423d/src/3_NumericalBasics/LinInterpols.jl#L150-L171">source</a></section></article><h2 id="Collect-variables:-macros"><a class="docs-heading-anchor" href="#Collect-variables:-macros">Collect variables: macros</a><a id="Collect-variables:-macros-1"></a><a class="docs-heading-anchor-permalink" href="#Collect-variables:-macros" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.@writeXSS" href="#HANKEstim.@writeXSS"><code>HANKEstim.@writeXSS</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@writeXSS()</code></pre><p>Write all single steady state variables into vectors XSS / XSSaggr.</p><p><strong>Requires</strong></p><p>(module) globals <code>state_names</code>, <code>control_names</code>, <code>aggr_names</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/fb44c9aadd0864c7232568c1fd7cd5e91356423d/src/3_NumericalBasics/MacroUtils.jl#L31-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.@make_fn" href="#HANKEstim.@make_fn"><code>HANKEstim.@make_fn</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@make_fn(fn_name)</code></pre><p>Create function <code>fn_name</code> that returns an instance of <code>struct</code> <code>IndexStruct</code> (created by <a href="steadystate.html#HANKEstim.@make_struct"><code>@make_struct</code></a>), mapping states and controls to indexes inferred from numerical parameters and compression indexes.</p><p><strong>Requires</strong></p><p>(module) global <code>state_names</code>, <code>control_names</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/fb44c9aadd0864c7232568c1fd7cd5e91356423d/src/3_NumericalBasics/MacroUtils.jl#L117-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.@make_fnaggr" href="#HANKEstim.@make_fnaggr"><code>HANKEstim.@make_fnaggr</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@make_fnaggr(fn_name)</code></pre><p>Create function <code>fn_name</code> that returns an instance of <code>struct</code> <code>IndexStructAggr</code> (created by <a href="steadystate.html#HANKEstim.@make_struct_aggr"><code>@make_struct_aggr</code></a>), mapping aggregate states and controls to values <code>1</code> to <code>length(aggr_names)</code> (both steady state and deviation from it).</p><p><strong>Requires</strong></p><p>(module) global <code>aggr_names</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/fb44c9aadd0864c7232568c1fd7cd5e91356423d/src/3_NumericalBasics/MacroUtils.jl#L90-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.@make_struct" href="#HANKEstim.@make_struct"><code>HANKEstim.@make_struct</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@make<em>struct(struct</em>name)</p><p>Make <code>struct</code> <code>struct_name</code> with two fields for every variable name in <code>s_names</code> (state variables) and <code>c_names</code> (control variables), together with fields for distribution-states and marginal value function-controls.</p><p><strong>Requires</strong></p><p>(module) globals <code>state_names</code>, <code>control_names</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/fb44c9aadd0864c7232568c1fd7cd5e91356423d/src/3_NumericalBasics/Structs.jl#L26-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANKEstim.@make_struct_aggr" href="#HANKEstim.@make_struct_aggr"><code>HANKEstim.@make_struct_aggr</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@make<em>struct</em>aggr(struct_name) </p><p>Make <code>struct</code> <code>struct_name</code> with two fields for every variable name in <code>aggr_names</code> (for steady state value and for deviation from it).</p><p><strong>Requires</strong></p><p>(module) global <code>aggr_names</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/BenjaminBorn/HANK_BusinessCycleAndInequality/blob/fb44c9aadd0864c7232568c1fd7cd5e91356423d/src/3_NumericalBasics/Structs.jl#L1-L9">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-BBL"><a class="tag is-link" href="#citeref-BBL">BBL</a>For details, see the paper <a href="https://cepr.org/active/publications/discussion_papers/dp.php?dpno=14364">Shocks, Frictions, and Inequality in US Business Cycles</a></li><li class="footnote" id="footnote-BL"><a class="tag is-link" href="#citeref-BL">BL</a>For details, see the paper <a href="https://cepr.org/active/publications/discussion_papers/dp.php?dpno=13071#">Solving heterogeneous agent models in discrete time with many idiosyncratic states by perturbation methods</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Home</a><a class="docs-footer-nextpage" href="linearization.html">Linearization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Monday 3 January 2022 14:55">Monday 3 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
